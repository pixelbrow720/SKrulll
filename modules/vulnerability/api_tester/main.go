package main

import (
	"bytes"
	"crypto/tls"
	"encoding/base64"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/golang-jwt/jwt/v4"
	"github.com/tidwall/gjson"
)

// Global variables for configuration
var (
	configFile      string
	apiSpecFile     string
	targetURL       string
	authToken       string
	concurrency     int
	outputDirectory string
	debug           bool
	config          Config
)

// Config represents the configuration for the API security tester
type Config struct {
	Target struct {
		BaseURL        string            `json:"base_url"`
		Headers        map[string]string `json:"headers"`
		AuthToken      string            `json:"auth_token"`
		AuthMethod     string            `json:"auth_method"`
		Username       string            `json:"username"`
		Password       string            `json:"password"`
		ClientID       string            `json:"client_id"`
		ClientSecret   string            `json:"client_secret"`
		TokenEndpoint  string            `json:"token_endpoint"`
		SkipTLSVerify  bool              `json:"skip_tls_verify"`
		RequestTimeout int               `json:"request_timeout"`
	} `json:"target"`
	Tests struct {
		Authentication bool `json:"authentication"`
		Authorization  bool `json:"authorization"`
		Injection      bool `json:"injection"`
		DataExposure   bool `json:"data_exposure"`
		RateLimit      bool `json:"rate_limit"`
		CORS           bool `json:"cors"`
		SSRF           bool `json:"ssrf"`
		MassAssignment bool `json:"mass_assignment"`
	} `json:"tests"`
	Execution struct {
		Concurrency      int    `json:"concurrency"`
		OutputDirectory  string `json:"output_directory"`
		RequestDelay     int    `json:"request_delay"`
		MaxRequestsPerEP int    `json:"max_requests_per_endpoint"`
		Debug            bool   `json:"debug"`
	} `json:"execution"`
	TestData struct {
		SQLInjection       []string          `json:"sql_injection"`
		NoSQLInjection     []string          `json:"nosql_injection"`
		CommandInjection   []string          `json:"command_injection"`
		PathTraversal      []string          `json:"path_traversal"`
		SensitiveDataRegex []string          `json:"sensitive_data_regex"`
		CustomParameters   map[string]string `json:"custom_parameters"`
	} `json:"test_data"`
}

// TestResult represents the result of a security test
type TestResult struct {
	Endpoint       string `json:"endpoint"`
	Method         string `json:"method"`
	TestType       string `json:"test_type"`
	Status         string `json:"status"`
	Description    string `json:"description"`
	Payload        string `json:"payload,omitempty"`
	ResponseCode   int    `json:"response_code,omitempty"`
	ResponseBody   string `json:"response_body,omitempty"`
	Evidence       string `json:"evidence,omitempty"`
	CVSS           string `json:"cvss,omitempty"`
	Recommendation string `json:"recommendation,omitempty"`
	Timestamp      string `json:"timestamp"`
}

// APIEndpoint represents an API endpoint extracted from OpenAPI spec
type APIEndpoint struct {
	Path        string
	Method      string
	Parameters  []APIParameter
	RequestBody *openapi3.RequestBodyRef
	Security    *openapi3.SecurityRequirements
	Description string
	OperationID string
}

// APIParameter represents a parameter for an API endpoint
type APIParameter struct {
	Name        string
	In          string
	Required    bool
	Type        string
	Format      string
	Description string
	Schema      *openapi3.SchemaRef
}

func init() {
	// Define command-line flags
	flag.StringVar(&configFile, "config", "", "Path to the configuration file")
	flag.StringVar(&apiSpecFile, "spec", "", "Path to the OpenAPI/Swagger specification file")
	flag.StringVar(&targetURL, "url", "", "Target API base URL")
	flag.StringVar(&authToken, "token", "", "Authentication token")
	flag.IntVar(&concurrency, "concurrency", 10, "Number of concurrent requests")
	flag.StringVar(&outputDirectory, "output", "reports", "Output directory for reports")
	flag.BoolVar(&debug, "debug", false, "Enable debug logging")
}

func main() {
	flag.Parse()

	// Log start of API security testing
	log.Println("Starting SKrulll API Security Tester")

	// Load configuration
	err := loadConfig()
	if err != nil {
		log.Fatalf("Error loading configuration: %v", err)
	}

	// Override config with command-line parameters if provided
	if targetURL != "" {
		config.Target.BaseURL = targetURL
	}
	if authToken != "" {
		config.Target.AuthToken = authToken
	}
	if concurrency > 0 {
		config.Execution.Concurrency = concurrency
	}
	if outputDirectory != "" {
		config.Execution.OutputDirectory = outputDirectory
	}
	if debug {
		config.Execution.Debug = debug
	}

	// Ensure output directory exists
	err = os.MkdirAll(config.Execution.OutputDirectory, 0755)
	if err != nil {
		log.Fatalf("Error creating output directory: %v", err)
	}

	// Parse OpenAPI/Swagger specification
	log.Printf("Parsing API specification: %s", apiSpecFile)
	endpoints, err := parseAPISpec(apiSpecFile)
	if err != nil {
		log.Fatalf("Error parsing API specification: %v", err)
	}
	log.Printf("Discovered %d API endpoints", len(endpoints))

	// Create HTTP client with appropriate configuration
	client := createHTTPClient()

	// Authenticate if needed and token not provided
	if config.Target.AuthToken == "" && (config.Target.AuthMethod != "" && config.Target.AuthMethod != "none") {
		token, err := authenticate(client)
		if err != nil {
			log.Printf("Warning: Authentication failed: %v", err)
		} else {
			config.Target.AuthToken = token
			log.Println("Authentication successful")
		}
	}

	// Prepare for testing
	var wg sync.WaitGroup
	sem := make(chan struct{}, config.Execution.Concurrency)
	results := make(chan TestResult)

	// Start result collector
	go collectResults(results)

	// Run security tests for each endpoint
	log.Println("Starting API security tests...")
	for _, endpoint := range endpoints {
		wg.Add(1)
		sem <- struct{}{}
		go func(ep APIEndpoint) {
			defer wg.Done()
			defer func() { <-sem }()
			runSecurityTests(client, ep, results)
		}(endpoint)
	}

	// Wait for all tests to complete
	wg.Wait()
	close(results)

	log.Println("API security testing completed")
}

// loadConfig loads the configuration from the specified file
func loadConfig() error {
	// Default configuration
	config = Config{
		Target: struct {
			BaseURL        string            `json:"base_url"`
			Headers        map[string]string `json:"headers"`
			AuthToken      string            `json:"auth_token"`
			AuthMethod     string            `json:"auth_method"`
			Username       string            `json:"username"`
			Password       string            `json:"password"`
			ClientID       string            `json:"client_id"`
			ClientSecret   string            `json:"client_secret"`
			TokenEndpoint  string            `json:"token_endpoint"`
			SkipTLSVerify  bool              `json:"skip_tls_verify"`
			RequestTimeout int               `json:"request_timeout"`
		}{
			Headers:        make(map[string]string),
			AuthMethod:     "none",
			RequestTimeout: 30,
		},
		Tests: struct {
			Authentication bool `json:"authentication"`
			Authorization  bool `json:"authorization"`
			Injection      bool `json:"injection"`
			DataExposure   bool `json:"data_exposure"`
			RateLimit      bool `json:"rate_limit"`
			CORS           bool `json:"cors"`
			SSRF           bool `json:"ssrf"`
			MassAssignment bool `json:"mass_assignment"`
		}{
			Authentication: true,
			Authorization:  true,
			Injection:      true,
			DataExposure:   true,
			RateLimit:      true,
			CORS:           true,
			SSRF:           true,
			MassAssignment: true,
		},
		Execution: struct {
			Concurrency      int    `json:"concurrency"`
			OutputDirectory  string `json:"output_directory"`
			RequestDelay     int    `json:"request_delay"`
			MaxRequestsPerEP int    `json:"max_requests_per_endpoint"`
			Debug            bool   `json:"debug"`
		}{
			Concurrency:      10,
			OutputDirectory:  "reports",
			RequestDelay:     100,
			MaxRequestsPerEP: 20,
			Debug:            false,
		},
		TestData: struct {
			SQLInjection       []string          `json:"sql_injection"`
			NoSQLInjection     []string          `json:"nosql_injection"`
			CommandInjection   []string          `json:"command_injection"`
			PathTraversal      []string          `json:"path_traversal"`
			SensitiveDataRegex []string          `json:"sensitive_data_regex"`
			CustomParameters   map[string]string `json:"custom_parameters"`
		}{
			SQLInjection: []string{
				"' OR 1=1 --",
				"\" OR 1=1 --",
				"1' OR '1'='1",
				"admin' --",
				"1; DROP TABLE users",
			},
			NoSQLInjection: []string{
				"{\"$gt\": \"\"}",
				"{\"$regex\": \".*\"}",
				"{\"$where\": \"return true\"}",
			},
			CommandInjection: []string{
				"; ls -la",
				"& ping -c 4 127.0.0.1",
				"| cat /etc/passwd",
			},
			PathTraversal: []string{
				"../../../etc/passwd",
				"..\\..\\..\\windows\\win.ini",
				"/etc/passwd",
			},
			SensitiveDataRegex: []string{
				"\\b\\d{16}\\b", // Credit card number
				"\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b", // Email
				"password[\"']?\\s*[:=]\\s*[\"']\\w+[\"']",              // Password in JSON/config
			},
			CustomParameters: make(map[string]string),
		},
	}

	// If no config file specified, use default config
	if configFile == "" {
		return nil
	}

	// Read configuration file
	data, err := ioutil.ReadFile(configFile)
	if err != nil {
		return fmt.Errorf("failed to read config file: %v", err)
	}

	// Parse JSON configuration
	err = json.Unmarshal(data, &config)
	if err != nil {
		return fmt.Errorf("failed to parse config file: %v", err)
	}

	return nil
}

// parseAPISpec parses an OpenAPI/Swagger specification file
func parseAPISpec(specFile string) ([]APIEndpoint, error) {
	var endpoints []APIEndpoint

	// Load the spec file
	loader := openapi3.NewLoader()
	doc, err := loader.LoadFromFile(specFile)
	if err != nil {
		return nil, fmt.Errorf("failed to load API spec: %v", err)
	}

	// Extract endpoints from the spec
	for path, pathItem := range doc.Paths {
		// Extract HTTP methods and their operations
		operations := map[string]*openapi3.Operation{
			http.MethodGet:     pathItem.Get,
			http.MethodPost:    pathItem.Post,
			http.MethodPut:     pathItem.Put,
			http.MethodDelete:  pathItem.Delete,
			http.MethodOptions: pathItem.Options,
			http.MethodHead:    pathItem.Head,
			http.MethodPatch:   pathItem.Patch,
			http.MethodTrace:   pathItem.Trace,
		}

		// Process each operation
		for method, operation := range operations {
			if operation == nil {
				continue
			}

			// Create endpoint
			endpoint := APIEndpoint{
				Path:        path,
				Method:      method,
				RequestBody: operation.RequestBody,
				Security:    operation.Security,
				Description: operation.Description,
				OperationID: operation.OperationID,
			}

			// Extract parameters
			for _, param := range operation.Parameters {
				if param.Value == nil {
					continue
				}

				endpoint.Parameters = append(endpoint.Parameters, APIParameter{
					Name:        param.Value.Name,
					In:          param.Value.In,
					Required:    param.Value.Required,
					Description: param.Value.Description,
					Schema:      param.Value.Schema,
				})
			}

			endpoints = append(endpoints, endpoint)
		}
	}

	return endpoints, nil
}

// createHTTPClient creates an HTTP client with the appropriate configuration
func createHTTPClient() *http.Client {
	// Create transport with TLS configuration
	transport := &http.Transport{
		TLSClientConfig: &tls.Config{
			InsecureSkipVerify: config.Target.SkipTLSVerify,
		},
	}

	// Create client with timeout
	client := &http.Client{
		Transport: transport,
		Timeout:   time.Duration(config.Target.RequestTimeout) * time.Second,
	}

	return client
}

// authenticate performs authentication using the configured method
func authenticate(client *http.Client) (string, error) {
	switch strings.ToLower(config.Target.AuthMethod) {
	case "basic":
		// Basic authentication doesn't return a token but we'll create an encoded version
		auth := base64.StdEncoding.EncodeToString([]byte(config.Target.Username + ":" + config.Target.Password))
		return "Basic " + auth, nil

	case "oauth2":
		// OAuth2 client credentials flow
		if config.Target.TokenEndpoint == "" {
			return "", fmt.Errorf("token endpoint not specified for OAuth2")
		}

		data := url.Values{}
		data.Set("grant_type", "client_credentials")
		data.Set("client_id", config.Target.ClientID)
		data.Set("client_secret", config.Target.ClientSecret)

		req, err := http.NewRequest("POST", config.Target.TokenEndpoint, strings.NewReader(data.Encode()))
		if err != nil {
			return "", err
		}

		req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
		resp, err := client.Do(req)
		if err != nil {
			return "", err
		}
		defer resp.Body.Close()

		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			return "", err
		}

		// Extract token from response
		token := gjson.GetBytes(body, "access_token").String()
		if token == "" {
			return "", fmt.Errorf("no access token in response")
		}

		return "Bearer " + token, nil

	case "custom":
		// Custom authentication - you would implement specific logic here
		return "", fmt.Errorf("custom authentication not implemented")

	case "none", "":
		return "", nil

	default:
		return "", fmt.Errorf("unsupported authentication method: %s", config.Target.AuthMethod)
	}
}

// runSecurityTests runs security tests for a specific API endpoint
func runSecurityTests(client *http.Client, endpoint APIEndpoint, results chan<- TestResult) {
	debugLog(fmt.Sprintf("Testing endpoint: %s %s", endpoint.Method, endpoint.Path))

	// Run different security tests based on configuration
	if config.Tests.Authentication {
		testAuthentication(client, endpoint, results)
	}

	if config.Tests.Authorization {
		testAuthorization(client, endpoint, results)
	}

	if config.Tests.Injection {
		testInjection(client, endpoint, results)
	}

	if config.Tests.DataExposure {
		testDataExposure(client, endpoint, results)
	}

	if config.Tests.RateLimit {
		testRateLimit(client, endpoint, results)
	}

	if config.Tests.CORS {
		testCORS(client, endpoint, results)
	}

	if config.Tests.SSRF {
		testSSRF(client, endpoint, results)
	}

	if config.Tests.MassAssignment {
		testMassAssignment(client, endpoint, results)
	}
}

// testAuthentication tests authentication bypass vulnerabilities
func testAuthentication(client *http.Client, endpoint APIEndpoint, results chan<- TestResult) {
	// Skip if this endpoint doesn't require authentication
	if endpoint.Security == nil || len(*endpoint.Security) == 0 {
		return
	}

	// Test with no authentication
	result := TestResult{
		Endpoint:    endpoint.Path,
		Method:      endpoint.Method,
		TestType:    "Authentication",
		Status:      "RUNNING",
		Description: "Testing if endpoint can be accessed without authentication",
		Timestamp:   time.Now().Format(time.RFC3339),
	}

	req, err := createRequest(endpoint, nil, nil, false)
	if err != nil {
		debugLog(fmt.Sprintf("Error creating request: %v", err))
		return
	}

	resp, err := client.Do(req)
	if err != nil {
		debugLog(fmt.Sprintf("Error making request: %v", err))
		return
	}
	defer resp.Body.Close()

	body, _ := ioutil.ReadAll(resp.Body)
	result.ResponseCode = resp.StatusCode
	result.ResponseBody = string(body)

	// Check if authentication bypass was successful
	if resp.StatusCode < 400 {
		result.Status = "VULNERABLE"
		result.Evidence = fmt.Sprintf("Endpoint accessible without authentication, status code: %d", resp.StatusCode)
		result.CVSS = "9.1" // AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N
		result.Recommendation = "Implement proper authentication checks for all secure endpoints"
	} else {
		result.Status = "SECURE"
	}

	results <- result
}

// testAuthorization tests authorization bypass vulnerabilities
func testAuthorization(client *http.Client, endpoint APIEndpoint, results chan<- TestResult) {
	// Skip for non-resource endpoints or methods that don't typically need specific authorization
	if endpoint.Method == http.MethodOptions || endpoint.Method == http.MethodHead {
		return
	}

	// Extract potential resource ID from path
	resourceIDPattern := regexp.MustCompile(`\{([^}]+)\}`)
	matches := resourceIDPattern.FindStringSubmatch(endpoint.Path)
	if len(matches) < 2 {
		// No resource ID parameter, can't test IDOR effectively
		return
	}

	// Test for IDOR (Insecure Direct Object Reference)
	result := TestResult{
		Endpoint:    endpoint.Path,
		Method:      endpoint.Method,
		TestType:    "Authorization - IDOR",
		Status:      "RUNNING",
		Description: "Testing for Insecure Direct Object Reference vulnerabilities",
		Timestamp:   time.Now().Format(time.RFC3339),
	}

	// Replace resource ID with a different ID (assumption testing)
	resourceParam := matches[1]
	testValues := []string{"1", "2", "admin", "administrator"}

	for _, testValue := range testValues {
		// Create request with test value
		params := make(map[string]string)
		params[resourceParam] = testValue

		req, err := createRequest(endpoint, params, nil, true)
		if err != nil {
			continue
		}

		resp, err := client.Do(req)
		if err != nil {
			continue
		}

		body, _ := ioutil.ReadAll(resp.Body)
		resp.Body.Close()

		result.ResponseCode = resp.StatusCode
		result.Payload = fmt.Sprintf("Parameter %s=%s", resourceParam, testValue)

		// Check if authorization bypass was successful
		if resp.StatusCode < 400 && !strings.Contains(string(body), "error") &&
			!strings.Contains(string(body), "unauthorized") && !strings.Contains(string(body), "not found") {
			result.Status = "POTENTIAL_VULNERABILITY"
			result.Evidence = fmt.Sprintf("Potential IDOR, resource accessible with ID=%s, status code: %d",
				testValue, resp.StatusCode)
			result.CVSS = "6.5" // AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N
			result.Recommendation = "Implement proper authorization checks for resource access"
			result.ResponseBody = string(body)
			results <- result
			return
		}
	}

	result.Status = "SECURE"
	results <- result
}

// testInjection tests various injection vulnerabilities
func testInjection(client *http.Client, endpoint APIEndpoint, results chan<- TestResult) {
	// Only test endpoints that have parameters or request body
	if len(endpoint.Parameters) == 0 && endpoint.RequestBody == nil {
		return
	}

	// Test SQL Injection
	testSQLInjection(client, endpoint, results)

	// Test NoSQL Injection
	testNoSQLInjection(client, endpoint, results)

	// Test Command Injection
	testCommandInjection(client, endpoint, results)

	// Test Path Traversal
	testPathTraversal(client, endpoint, results)
}

// testSQLInjection tests for SQL injection vulnerabilities
func testSQLInjection(client *http.Client, endpoint APIEndpoint, results chan<- TestResult) {
	result := TestResult{
		Endpoint:    endpoint.Path,
		Method:      endpoint.Method,
		TestType:    "SQL Injection",
		Status:      "RUNNING",
		Description: "Testing for SQL injection vulnerabilities",
		Timestamp:   time.Now().Format(time.RFC3339),
	}

	// Test each parameter for SQL injection
	for _, param := range endpoint.Parameters {
		if param.In != "query" && param.In != "path" {
			continue
		}

		for _, payload := range config.TestData.SQLInjection {
			params := make(map[string]string)
			params[param.Name] = payload

			req, err := createRequest(endpoint, params, nil, true)
			if err != nil {
				continue
			}

			resp, err := client.Do(req)
			if err != nil {
				continue
			}

			body, _ := ioutil.ReadAll(resp.Body)
			resp.Body.Close()

			result.ResponseCode = resp.StatusCode
			result.Payload = fmt.Sprintf("%s=%s", param.Name, payload)

			// Check for SQL error signatures
			sqlErrors := []string{
				"SQL syntax", "ORA-", "mysql_fetch_array", "Warning: mysql_",
				"SQLite3::", "PostgreSQL", "driver.OleDb", "System.Data.SQL",
			}

			for _, errSig := range sqlErrors {
				if strings.Contains(string(body), errSig) {
					result.Status = "VULNERABLE"
					result.Evidence = fmt.Sprintf("SQL error detected: contains '%s'", errSig)
					result.CVSS = "8.6" // AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N
					result.Recommendation = "Use parameterized queries and input validation"
					result.ResponseBody = string(body)
					results <- result
					return
				}
			}
		}
	}

	// Also test request body parameters if available
	if endpoint.RequestBody != nil && endpoint.Method != http.MethodGet {
		// Create a simple JSON body with SQL injection payloads
		for _, payload := range config.TestData.SQLInjection {
			body := map[string]string{"id": payload, "name": payload}
			jsonBody, _ := json.Marshal(body)

			req, err := createRequest(endpoint, nil, jsonBody, true)
			if err != nil {
				continue
			}

			resp, err := client.Do(req)
			if err != nil {
				continue
			}

			respBody, _ := ioutil.ReadAll(resp.Body)
			resp.Body.Close()

			result.ResponseCode = resp.StatusCode
			result.Payload = string(jsonBody)

			// Check for SQL error signatures
			sqlErrors := []string{
				"SQL syntax", "ORA-", "mysql_fetch_array", "Warning: mysql_",
				"SQLite3::", "PostgreSQL", "driver.OleDb", "System.Data.SQL",
			}

			for _, errSig := range sqlErrors {
				if strings.Contains(string(respBody), errSig) {
					result.Status = "VULNERABLE"
					result.Evidence = fmt.Sprintf("SQL error detected in response body: contains '%s'", errSig)
					result.CVSS = "8.6" // AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N
					result.Recommendation = "Use parameterized queries and validate all JSON inputs"
					result.ResponseBody = string(respBody)
					results <- result
					return
				}
			}
		}
	}

	result.Status = "SECURE"
	results <- result
}

// testNoSQLInjection tests for NoSQL injection vulnerabilities
func testNoSQLInjection(client *http.Client, endpoint APIEndpoint, results chan<- TestResult) {
	result := TestResult{
		Endpoint:    endpoint.Path,
		Method:      endpoint.Method,
		TestType:    "NoSQL Injection",
		Status:      "RUNNING",
		Description: "Testing for NoSQL injection vulnerabilities",
		Timestamp:   time.Now().Format(time.RFC3339),
	}

	// For NoSQL injection, primarily focus on request body for JSON endpoints
	if endpoint.RequestBody != nil && endpoint.Method != http.MethodGet {
		for _, payload := range config.TestData.NoSQLInjection {
			// Try to construct a JSON body with NoSQL operators
			body := map[string]interface{}{}
			err := json.Unmarshal([]byte(fmt.Sprintf(`{"id": %s}`, payload)), &body)
			if err != nil {
				continue
			}

			jsonBody, _ := json.Marshal(body)
			req, err := createRequest(endpoint, nil, jsonBody, true)
			if err != nil {
				continue
			}

			resp, err := client.Do(req)
			if err != nil {
				continue
			}

			respBody, _ := ioutil.ReadAll(resp.Body)
			resp.Body.Close()

			result.ResponseCode = resp.StatusCode
			result.Payload = string(jsonBody)

			// Check for unexpected success or specific NoSQL errors
			if (resp.StatusCode == 200 && strings.Contains(payload, "$")) ||
				strings.Contains(string(respBody), "mongodb") ||
				strings.Contains(string(respBody), "mongoose") {
				result.Status = "POTENTIAL_VULNERABILITY"
				result.Evidence = "Potential NoSQL injection: operator accepted without error"
				result.CVSS = "7.5" // AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N
				result.Recommendation = "Validate and sanitize all JSON input, especially with operators"
				result.ResponseBody = string(respBody)
				results <- result
				return
			}
		}
	}

	result.Status = "SECURE"
	results <- result
}

// testCommandInjection tests for command injection vulnerabilities
func testCommandInjection(client *http.Client, endpoint APIEndpoint, results chan<- TestResult) {
	result := TestResult{
		Endpoint:    endpoint.Path,
		Method:      endpoint.Method,
		TestType:    "Command Injection",
		Status:      "RUNNING",
		Description: "Testing for command injection vulnerabilities",
		Timestamp:   time.Now().Format(time.RFC3339),
	}

	// Test parameters for command injection
	for _, param := range endpoint.Parameters {
		// Focus on parameters that might be used in commands
		paramNameLower := strings.ToLower(param.Name)
		if !containsAny(paramNameLower, []string{"file", "path", "command", "exec", "run", "host", "ip", "url"}) {
			continue
		}

		for _, payload := range config.TestData.CommandInjection {
			params := make(map[string]string)
			params[param.Name] = payload

			req, err := createRequest(endpoint, params, nil, true)
			if err != nil {
				continue
			}

			resp, err := client.Do(req)
			if err != nil {
				continue
			}

			body, _ := ioutil.ReadAll(resp.Body)
			resp.Body.Close()

			result.ResponseCode = resp.StatusCode
			result.Payload = fmt.Sprintf("%s=%s", param.Name, payload)

			// Check for command execution evidence
			commandEvidence := []string{
				"uid=", "root:", "bin/bash", "bin/sh", "windows\\system32",
				"Program Files", "etc/passwd", "win.ini",
			}

			for _, evidence := range commandEvidence {
				if strings.Contains(string(body), evidence) {
					result.Status = "VULNERABLE"
					result.Evidence = fmt.Sprintf("Command injection detected: response contains '%s'", evidence)
					result.CVSS = "9.8" // AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
					result.Recommendation = "Never use user input directly in system commands, use allowlists"
					result.ResponseBody = string(body)
					results <- result
					return
				}
			}
		}
	}

	result.Status = "SECURE"
	results <- result
}

// testPathTraversal tests for path traversal vulnerabilities
func testPathTraversal(client *http.Client, endpoint APIEndpoint, results chan<- TestResult) {
	result := TestResult{
		Endpoint:    endpoint.Path,
		Method:      endpoint.Method,
		TestType:    "Path Traversal",
		Status:      "RUNNING",
		Description: "Testing for path traversal vulnerabilities",
		Timestamp:   time.Now().Format(time.RFC3339),
	}

	// Test parameters for path traversal
	for _, param := range endpoint.Parameters {
		// Focus on parameters that might be used with files
		paramNameLower := strings.ToLower(param.Name)
		if !containsAny(paramNameLower, []string{"file", "path", "directory", "folder", "doc", "document", "read", "upload"}) {
			continue
		}

		for _, payload := range config.TestData.PathTraversal {
			params := make(map[string]string)
			params[param.Name] = payload

			req, err := createRequest(endpoint, params, nil, true)
			if err != nil {
				continue
			}

			resp, err := client.Do(req)
			if err != nil {
				continue
			}

			body, _ := ioutil.ReadAll(resp.Body)
			resp.Body.Close()

			result.ResponseCode = resp.StatusCode
			result.Payload = fmt.Sprintf("%s=%s", param.Name, payload)

			// Check for file content evidence
			fileEvidence := []string{
				"root:", "bin/bash", "etc/passwd", "win.ini", "ProgramData",
				"boot.ini", "Windows", "System32",
			}

			for _, evidence := range fileEvidence {
				if strings.Contains(string(body), evidence) {
					result.Status = "VULNERABLE"
					result.Evidence = fmt.Sprintf("Path traversal detected: response contains '%s'", evidence)
					result.CVSS = "7.5" // AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N
					result.Recommendation = "Use proper file path validation and restrict access to file system"
					result.ResponseBody = string(body)
					results <- result
					return
				}
			}
		}
	}

	result.Status = "SECURE"
	results <- result
}

// testDataExposure tests for sensitive data exposure
func testDataExposure(client *http.Client, endpoint APIEndpoint, results chan<- TestResult) {
	result := TestResult{
		Endpoint:    endpoint.Path,
		Method:      endpoint.Method,
		TestType:    "Sensitive Data Exposure",
		Status:      "RUNNING",
		Description: "Testing for sensitive data exposure",
		Timestamp:   time.Now().Format(time.RFC3339),
	}

	// Create a regular request to check for sensitive data in the response
	req, err := createRequest(endpoint, nil, nil, true)
	if err != nil {
		return
	}

	resp, err := client.Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, _ := ioutil.ReadAll(resp.Body)
	result.ResponseCode = resp.StatusCode

	// Check for sensitive data patterns in the response
	for _, pattern := range config.TestData.SensitiveDataRegex {
		re, err := regexp.Compile(pattern)
		if err != nil {
			continue
		}

		matches := re.FindAllString(string(body), -1)
		if len(matches) > 0 {
			result.Status = "POTENTIAL_VULNERABILITY"
			result.Evidence = fmt.Sprintf("Potential sensitive data found: %d matches for pattern '%s'", len(matches), pattern)
			result.CVSS = "5.9" // AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N
			result.Recommendation = "Ensure sensitive data is properly masked or encrypted"
			// Don't include the full response body to avoid copying sensitive data
			result.ResponseBody = "*** Response contained potentially sensitive data ***"
			results <- result
			return
		}
	}

	// Check for common sensitive headers
	sensitiveHeaders := []string{"X-API-Key", "Authorization", "Secret", "Key", "Password", "Token"}
	for _, header := range sensitiveHeaders {
		if resp.Header.Get(header) != "" {
			result.Status = "POTENTIAL_VULNERABILITY"
			result.Evidence = fmt.Sprintf("Sensitive header '%s' is returned in response", header)
			result.CVSS = "4.3" // AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N
			result.Recommendation = "Do not return sensitive authentication headers in responses"
			results <- result
			return
		}
	}

	// Also check JWT tokens for weak algorithms
	authHeader := resp.Header.Get("Authorization")
	if strings.HasPrefix(authHeader, "Bearer ") {
		tokenStr := strings.TrimPrefix(authHeader, "Bearer ")
		token, _ := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) {
			return nil, nil // We don't need to validate, just inspect
		})

		if token != nil && token.Header["alg"] == "none" || token.Header["alg"] == "HS256" {
			result.Status = "VULNERABLE"
			result.Evidence = fmt.Sprintf("Weak JWT algorithm: %v", token.Header["alg"])
			result.CVSS = "7.5" // AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N
			result.Recommendation = "Use strong JWT algorithms like RS256 or ES256"
			results <- result
			return
		}
	}

	result.Status = "SECURE"
	results <- result
}

// testRateLimit tests for rate limiting vulnerabilities
func testRateLimit(client *http.Client, endpoint APIEndpoint, results chan<- TestResult) {
	result := TestResult{
		Endpoint:    endpoint.Path,
		Method:      endpoint.Method,
		TestType:    "Rate Limit",
		Status:      "RUNNING",
		Description: "Testing for rate limiting vulnerabilities",
		Timestamp:   time.Now().Format(time.RFC3339),
	}

	// Skip for idempotent methods to avoid side effects
	if endpoint.Method == http.MethodGet || endpoint.Method == http.MethodHead {
		// Only test rate limits for these if they are likely high-value endpoints
		if !containsAny(strings.ToLower(endpoint.Path), []string{"user", "admin", "auth", "login", "api", "token"}) {
			return
		}
	}

	// Make multiple requests in quick succession
	numRequests := 10
	responseCodes := make([]int, numRequests)
	delayMillis := 100

	for i := 0; i < numRequests; i++ {
		req, err := createRequest(endpoint, nil, nil, true)
		if err != nil {
			return
		}

		resp, err := client.Do(req)
		if err != nil {
			continue
		}

		responseCodes[i] = resp.StatusCode
		resp.Body.Close()

		// Tiny delay to avoid completely hammering the server
		time.Sleep(time.Duration(delayMillis) * time.Millisecond)
	}

	// Check if any rate limiting was applied
	var limited bool
	var limitHeaders bool

	// Check for rate limit status codes (429)
	for _, code := range responseCodes {
		if code == 429 {
			limited = true
			break
		}
	}

	// Check if common rate limit headers exist in the last response
	req, _ := createRequest(endpoint, nil, nil, true)
	resp, err := client.Do(req)
	if err == nil {
		defer resp.Body.Close()
		rateLimitHeaders := []string{
			"X-Rate-Limit", "X-Rate-Limit-Limit", "X-Rate-Limit-Remaining",
			"X-Rate-Limit-Reset", "Retry-After", "RateLimit-Limit",
			"RateLimit-Remaining", "RateLimit-Reset",
		}

		for _, header := range rateLimitHeaders {
			if resp.Header.Get(header) != "" {
				limitHeaders = true
				break
			}
		}
	}

	if !limited && !limitHeaders {
		result.Status = "POTENTIAL_VULNERABILITY"
		result.Evidence = fmt.Sprintf("No rate limiting detected after %d requests", numRequests)
		result.CVSS = "5.3" // AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L
		result.Recommendation = "Implement rate limiting for all API endpoints, especially for authentication and state-changing operations"
	} else {
		result.Status = "SECURE"
	}

	results <- result
}

// testCORS tests for CORS misconfigurations
func testCORS(client *http.Client, endpoint APIEndpoint, results chan<- TestResult) {
	result := TestResult{
		Endpoint:    endpoint.Path,
		Method:      endpoint.Method,
		TestType:    "CORS Misconfiguration",
		Status:      "RUNNING",
		Description: "Testing for CORS security misconfigurations",
		Timestamp:   time.Now().Format(time.RFC3339),
	}

	// Try various origins to check CORS config
	maliciousOrigins := []string{
		"https://evil.com",
		"https://attacker.org",
		"null", // Special case
	}

	for _, origin := range maliciousOrigins {
		req, err := createRequest(endpoint, nil, nil, true)
		if err != nil {
			continue
		}

		// Add the Origin header
		req.Header.Set("Origin", origin)

		resp, err := client.Do(req)
		if err != nil {
			continue
		}
		defer resp.Body.Close()

		// Check CORS headers
		allowOrigin := resp.Header.Get("Access-Control-Allow-Origin")
		allowCredentials := resp.Header.Get("Access-Control-Allow-Credentials")

		// Check for dangerous CORS configurations
		if allowOrigin == "*" || allowOrigin == origin {
			result.Payload = fmt.Sprintf("Origin: %s", origin)
			result.ResponseCode = resp.StatusCode

			// Most severe: allows credentials with permissive origin
			if allowOrigin == origin && allowCredentials == "true" {
				result.Status = "VULNERABLE"
				result.Evidence = fmt.Sprintf("Dangerous CORS config: Access-Control-Allow-Origin: %s, Access-Control-Allow-Credentials: true", allowOrigin)
				result.CVSS = "6.5" // AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N
				result.Recommendation = "Do not combine Access-Control-Allow-Origin: <origin> with Access-Control-Allow-Credentials: true"
				results <- result
				return
			}

			// Wildcard origin is risky but less severe if credentials aren't allowed
			if allowOrigin == "*" {
				result.Status = "POTENTIAL_VULNERABILITY"
				result.Evidence = "Permissive CORS config: Access-Control-Allow-Origin: *"
				result.CVSS = "3.7" // AV:N/AC:H/PR:N/UI:R/S:U/C:L/I:N/A:N
				result.Recommendation = "Restrict CORS access to only trusted domains"
				results <- result
				return
			}
		}
	}

	result.Status = "SECURE"
	results <- result
}

// testSSRF tests for Server-Side Request Forgery vulnerabilities
func testSSRF(client *http.Client, endpoint APIEndpoint, results chan<- TestResult) {
	result := TestResult{
		Endpoint:    endpoint.Path,
		Method:      endpoint.Method,
		TestType:    "SSRF",
		Status:      "RUNNING",
		Description: "Testing for Server-Side Request Forgery vulnerabilities",
		Timestamp:   time.Now().Format(time.RFC3339),
	}

	// Look for parameters that might be used to make server-side requests
	ssrfParams := []string{}
	for _, param := range endpoint.Parameters {
		paramNameLower := strings.ToLower(param.Name)
		if containsAny(paramNameLower, []string{"url", "uri", "link", "href", "path", "site", "load", "file", "upload"}) {
			ssrfParams = append(ssrfParams, param.Name)
		}
	}

	if len(ssrfParams) == 0 {
		// No likely SSRF parameters
		return
	}

	// SSRF payloads to test
	ssrfPayloads := []string{
		"http://169.254.169.254/latest/meta-data/", // AWS metadata
		"http://127.0.0.1:22",                      // SSH
		"http://localhost:8080",                    // Local service
		"file:///etc/passwd",                       // Local file
		"http://example.com@internal-service",      // URL confusion
	}

	// Test each potential SSRF parameter
	for _, param := range ssrfParams {
		for _, payload := range ssrfPayloads {
			params := make(map[string]string)
			params[param] = payload

			req, err := createRequest(endpoint, params, nil, true)
			if err != nil {
				continue
			}

			resp, err := client.Do(req)
			if err != nil {
				continue
			}

			body, _ := ioutil.ReadAll(resp.Body)
			resp.Body.Close()

			result.ResponseCode = resp.StatusCode
			result.Payload = fmt.Sprintf("%s=%s", param, payload)

			// Check for indicators of successful SSRF
			ssrfEvidence := []string{
				"ami-id", "instance-id", "instance-type", // AWS metadata
				"ssh", "OpenSSH", // SSH banner
				"uid=", "root:", "mysql", // System files
				"Internal Server Error", // Potential connection to internal service
			}

			for _, evidence := range ssrfEvidence {
				if strings.Contains(string(body), evidence) {
					result.Status = "VULNERABLE"
					result.Evidence = fmt.Sprintf("Potential SSRF detected: response contains '%s'", evidence)
					result.CVSS = "7.7" // AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N
					result.Recommendation = "Implement URL allowlists and prevent access to internal resources"
					result.ResponseBody = string(body)
					results <- result
					return
				}
			}
		}
	}

	// Also check for SSRF in JSON body for POST/PUT requests
	if (endpoint.Method == http.MethodPost || endpoint.Method == http.MethodPut) && endpoint.RequestBody != nil {
		for _, payload := range ssrfPayloads {
			// Create a JSON body with potential SSRF fields
			body := map[string]string{
				"url":  payload,
				"uri":  payload,
				"href": payload,
				"link": payload,
				"src":  payload,
			}
			jsonBody, _ := json.Marshal(body)

			req, err := createRequest(endpoint, nil, jsonBody, true)
			if err != nil {
				continue
			}

			resp, err := client.Do(req)
			if err != nil {
				continue
			}

			respBody, _ := ioutil.ReadAll(resp.Body)
			resp.Body.Close()

			result.ResponseCode = resp.StatusCode
			result.Payload = string(jsonBody)

			// Check for indicators of successful SSRF (same as above)
			ssrfEvidence := []string{
				"ami-id", "instance-id", "instance-type",
				"ssh", "OpenSSH",
				"uid=", "root:", "mysql",
				"Internal Server Error",
			}

			for _, evidence := range ssrfEvidence {
				if strings.Contains(string(respBody), evidence) {
					result.Status = "VULNERABLE"
					result.Evidence = fmt.Sprintf("Potential SSRF in JSON body: response contains '%s'", evidence)
					result.CVSS = "7.7" // AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N
					result.Recommendation = "Validate and sanitize URLs in all JSON fields"
					result.ResponseBody = string(respBody)
					results <- result
					return
				}
			}
		}
	}

	result.Status = "SECURE"
	results <- result
}

// testMassAssignment tests for mass assignment vulnerabilities
func testMassAssignment(client *http.Client, endpoint APIEndpoint, results chan<- TestResult) {
	// Only test endpoints that likely update resources
	if endpoint.Method != http.MethodPost && endpoint.Method != http.MethodPut && endpoint.Method != http.MethodPatch {
		return
	}

	result := TestResult{
		Endpoint:    endpoint.Path,
		Method:      endpoint.Method,
		TestType:    "Mass Assignment",
		Status:      "RUNNING",
		Description: "Testing for mass assignment vulnerabilities",
		Timestamp:   time.Now().Format(time.RFC3339),
	}

	// Create a request with sensitive parameters that shouldn't be mass-assignable
	sensitiveParams := []string{
		"admin", "isAdmin", "role", "roles", "permission", "permissions",
		"access_level", "accessLevel", "verified", "is_verified",
		"user_id", "userId", "owner_id", "ownerId", "creator",
	}

	// Create a JSON body with these sensitive parameters
	body := map[string]interface{}{}

	// Add some regular parameters
	body["name"] = "Test User"
	body["email"] = "test@example.com"

	// Add each sensitive parameter
	for _, param := range sensitiveParams {
		// Try different true values
		if containsAny(param, []string{"admin", "verified", "permission"}) {
			body[param] = true // Boolean
		} else if containsAny(param, []string{"role", "level"}) {
			body[param] = "admin" // String
		} else if containsAny(param, []string{"id", "owner"}) {
			body[param] = 1 // Numeric ID
		}
	}

	jsonBody, _ := json.Marshal(body)

	req, err := createRequest(endpoint, nil, jsonBody, true)
	if err != nil {
		return
	}

	resp, err := client.Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	respBody, _ := ioutil.ReadAll(resp.Body)
	result.ResponseCode = resp.StatusCode
	result.Payload = string(jsonBody)

	// Check if request was accepted
	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		// Check if any of the sensitive parameters appear in the response
		for _, param := range sensitiveParams {
			if strings.Contains(string(respBody), param) {
				result.Status = "POTENTIAL_VULNERABILITY"
				result.Evidence = fmt.Sprintf("Potential mass assignment: parameter '%s' accepted and reflected in response", param)
				result.CVSS = "6.5" // AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N
				result.Recommendation = "Implement allowlists for assignable parameters and explicitly protect sensitive properties"
				result.ResponseBody = string(respBody)
				results <- result
				return
			}
		}
	}

	result.Status = "SECURE"
	results <- result
}

// createRequest creates an HTTP request for an API endpoint
func createRequest(endpoint APIEndpoint, params map[string]string, jsonBody []byte, withAuth bool) (*http.Request, error) {
	// Build the URL with path parameters
	path := endpoint.Path
	if params != nil {
		for name, value := range params {
			// Replace path parameters
			path = strings.Replace(path, fmt.Sprintf("{%s}", name), url.PathEscape(value), -1)
		}
	}

	// Build the full URL with query parameters
	fullURL := config.Target.BaseURL
	if !strings.HasSuffix(fullURL, "/") && !strings.HasPrefix(path, "/") {
		fullURL += "/"
	}
	fullURL += path

	// Add query parameters for GET requests
	if endpoint.Method == http.MethodGet && params != nil {
		queryParams := url.Values{}
		for name, value := range params {
			// Only add as query parameter if not already used as path parameter
			if !strings.Contains(endpoint.Path, fmt.Sprintf("{%s}", name)) {
				queryParams.Add(name, value)
			}
		}
		if len(queryParams) > 0 {
			if strings.Contains(fullURL, "?") {
				fullURL += "&" + queryParams.Encode()
			} else {
				fullURL += "?" + queryParams.Encode()
			}
		}
	}

	// Create the request
	var req *http.Request
	var err error

	if jsonBody != nil {
		req, err = http.NewRequest(endpoint.Method, fullURL, bytes.NewBuffer(jsonBody))
		req.Header.Set("Content-Type", "application/json")
	} else if endpoint.Method != http.MethodGet && params != nil {
		// For non-GET requests, use form data for parameters
		formData := url.Values{}
		for name, value := range params {
			// Only add as form data if not already used as path parameter
			if !strings.Contains(endpoint.Path, fmt.Sprintf("{%s}", name)) {
				formData.Add(name, value)
			}
		}
		req, err = http.NewRequest(endpoint.Method, fullURL, strings.NewReader(formData.Encode()))
		req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	} else {
		req, err = http.NewRequest(endpoint.Method, fullURL, nil)
	}

	if err != nil {
		return nil, err
	}

	// Add authorization if needed
	if withAuth && config.Target.AuthToken != "" {
		// Check if the token includes the auth type (e.g., "Bearer ")
		if strings.HasPrefix(strings.ToLower(config.Target.AuthToken), "bearer ") ||
			strings.HasPrefix(strings.ToLower(config.Target.AuthToken), "basic ") {
			req.Header.Set("Authorization", config.Target.AuthToken)
		} else {
			req.Header.Set("Authorization", "Bearer "+config.Target.AuthToken)
		}
	}

	// Add other headers from config
	for name, value := range config.Target.Headers {
		req.Header.Set(name, value)
	}

	return req, nil
}

// collectResults collects and processes test results
func collectResults(results <-chan TestResult) {
	// Create a map to organize results by endpoint
	endpointResults := make(map[string][]TestResult)
	vulnerableCount := 0
	potentialCount := 0
	secureCount := 0

	// Process all results
	for result := range results {
		key := fmt.Sprintf("%s %s", result.Method, result.Endpoint)
		endpointResults[key] = append(endpointResults[key], result)

		// Count by status
		switch result.Status {
		case "VULNERABLE":
			vulnerableCount++
		case "POTENTIAL_VULNERABILITY":
			potentialCount++
		case "SECURE":
			secureCount++
		}
	}

	// Create summary report
	summary := map[string]interface{}{
		"scan_date":       time.Now().Format(time.RFC3339),
		"target":          config.Target.BaseURL,
		"endpoints_count": len(endpointResults),
		"results": map[string]int{
			"vulnerable": vulnerableCount,
			"potential":  potentialCount,
			"secure":     secureCount,
		},
	}

	// Save detailed results
	saveResults(endpointResults, summary)
}

// saveResults saves test results to files with improved structure for integration with the main reporting system
func saveResults(endpointResults map[string][]TestResult, summary map[string]interface{}) {
	// Create output directory if it doesn't exist
	outputDir := config.Execution.OutputDirectory
	os.MkdirAll(outputDir, 0755)

	// Create timestamp for filenames
	timestamp := time.Now().Format("20060102-150405")

	// Create a unified report structure optimized for integration with the main reporting system
	unifiedReport := map[string]interface{}{
		"scan_id":   fmt.Sprintf("api-scan-%s", timestamp),
		"scan_type": "api_security",
		"timestamp": time.Now().Format(time.RFC3339),
		"target":    config.Target.BaseURL,
		"summary":   summary,
		"api_security": map[string]interface{}{
			"endpoints":       make(map[string]interface{}),
			"vulnerabilities": []map[string]interface{}{},
		},
		// Add metadata for reporting system integration
		"metadata": map[string]interface{}{
			"version":       "1.0",
			"tool":          "SKrulll API Security Tester",
			"report_format": "unified",
			"compatible_with": []string{
				"reporting_system",
				"vulnerability_dashboard",
				"security_metrics",
			},
		},
	}

	// Process vulnerabilities and endpoints
	vulnResults := []TestResult{}
	endpointMap := make(map[string]interface{})

	for endpoint, results := range endpointResults {
		endpointData := map[string]interface{}{
			"path":                endpoint,
			"findings_count":      len(results),
			"vulnerability_count": 0,
			"potential_count":     0,
			"secure_count":        0,
		}

		for _, result := range results {
			// Count by status
			switch result.Status {
			case "VULNERABLE":
				endpointData["vulnerability_count"] = endpointData["vulnerability_count"].(int) + 1
			case "POTENTIAL_VULNERABILITY":
				endpointData["potential_count"] = endpointData["potential_count"].(int) + 1
			case "SECURE":
				endpointData["secure_count"] = endpointData["secure_count"].(int) + 1
			}

			// Collect vulnerabilities
			if result.Status == "VULNERABLE" || result.Status == "POTENTIAL_VULNERABILITY" {
				vulnResults = append(vulnResults, result)

				// Add to unified report with enhanced metadata for better reporting system integration
				severity := getSeverityFromCVSS(result.CVSS)
				vulnMap := map[string]interface{}{
					"id":             fmt.Sprintf("api-vuln-%s-%d", timestamp, len(unifiedReport["api_security"].(map[string]interface{})["vulnerabilities"].([]map[string]interface{}))),
					"name":           fmt.Sprintf("%s in %s %s", result.TestType, result.Method, result.Endpoint),
					"endpoint":       result.Endpoint,
					"method":         result.Method,
					"test_type":      result.TestType,
					"status":         result.Status,
					"description":    result.Description,
					"evidence":       result.Evidence,
					"recommendation": result.Recommendation,
					"severity":       severity,
					"cvss_score":     result.CVSS,
					"timestamp":      result.Timestamp,
					"impact":         fmt.Sprintf("This vulnerability could allow attackers to %s", getImpactDescription(result.TestType, result.Status)),
					"details": map[string]interface{}{
						"payload":       result.Payload,
						"response_code": result.ResponseCode,
						"test_id":       fmt.Sprintf("API-SEC-%s-%s", strings.ToUpper(severity), timestamp[:8]),
						"category":      "API Security",
						"cwe":           getCWEForTestType(result.TestType),
					},
				}

				// Only include response body if it's not sensitive data
				if !strings.Contains(result.TestType, "Data Exposure") {
					vulnMap["details"].(map[string]interface{})["response_snippet"] = truncateString(result.ResponseBody, 500)
				}

				unifiedReport["api_security"].(map[string]interface{})["vulnerabilities"] = append(
					unifiedReport["api_security"].(map[string]interface{})["vulnerabilities"].([]map[string]interface{}),
					vulnMap)
			}
		}

		endpointMap[endpoint] = endpointData
	}

	// Add endpoints to unified report
	unifiedReport["api_security"].(map[string]interface{})["endpoints"] = endpointMap

	// Add risk_score to each endpoint for proper severity calculation in the reporting system
	for key, endpoint := range endpointMap {
		endpointData := endpoint.(map[string]interface{})
		vulnCount := endpointData["vulnerability_count"].(int)
		potentialCount := endpointData["potential_count"].(int)

		// Calculate risk score based on vulnerability counts
		riskScore := float64(vulnCount)*1.0 + float64(potentialCount)*0.5
		endpointData["risk_score"] = riskScore

		// Add description and recommendation if missing
		if _, ok := endpointData["description"]; !ok {
			endpointData["description"] = fmt.Sprintf("Security assessment for endpoint %s", key)
		}

		if _, ok := endpointData["recommendation"]; !ok {
			if vulnCount > 0 || potentialCount > 0 {
				endpointData["recommendation"] = "Address identified security issues and implement proper input validation and access controls"
			} else {
				endpointData["recommendation"] = "Continue monitoring this endpoint for security issues"
			}
		}

		// Add impact assessment
		if _, ok := endpointData["impact"]; !ok {
			if vulnCount > 0 {
				endpointData["impact"] = "This endpoint has critical security vulnerabilities that could lead to unauthorized access or data exposure"
			} else if potentialCount > 0 {
				endpointData["impact"] = "This endpoint has potential security weaknesses that might be exploitable under certain conditions"
			} else {
				endpointData["impact"] = "No significant security impact identified for this endpoint"
			}
		}
	}

	// Save unified report (main integration point)
	unifiedFile := filepath.Join(outputDir, fmt.Sprintf("unified-report-%s.json", timestamp))
	unifiedJSON, _ := json.MarshalIndent(unifiedReport, "", "  ")
	err := ioutil.WriteFile(unifiedFile, unifiedJSON, 0644)
	if err != nil {
		log.Printf("Error writing unified report file: %v", err)
	} else {
		log.Printf("Unified report saved to: %s", unifiedFile)
	}

	// Save summary as JSON (for backward compatibility)
	summaryFile := filepath.Join(outputDir, fmt.Sprintf("summary-%s.json", timestamp))
	summaryJSON, _ := json.MarshalIndent(summary, "", "  ")
	err = ioutil.WriteFile(summaryFile, summaryJSON, 0644)
	if err != nil {
		log.Printf("Error writing summary file: %v", err)
	} else {
		log.Printf("Summary report saved to: %s", summaryFile)
	}

	// Save vulnerabilities report (only vulnerable and potential findings)
	if len(vulnResults) > 0 {
		vulnFile := filepath.Join(outputDir, fmt.Sprintf("vulnerabilities-%s.json", timestamp))
		vulnJSON, _ := json.MarshalIndent(vulnResults, "", "  ")
		err := ioutil.WriteFile(vulnFile, vulnJSON, 0644)
		if err != nil {
			log.Printf("Error writing vulnerabilities file: %v", err)
		} else {
			log.Printf("Vulnerabilities report saved to: %s", vulnFile)
		}
	}

	// Save full detailed results
	detailedFile := filepath.Join(outputDir, fmt.Sprintf("detailed-%s.json", timestamp))
	allResults := []TestResult{}
	for _, results := range endpointResults {
		allResults = append(allResults, results...)
	}
	detailedJSON, _ := json.MarshalIndent(allResults, "", "  ")
	err = ioutil.WriteFile(detailedFile, detailedJSON, 0644)
	if err != nil {
		log.Printf("Error writing detailed file: %v", err)
	} else {
		log.Printf("Detailed report saved to: %s", detailedFile)
	}

	// Generate HTML report
	generateHTMLReport(endpointResults, summary, filepath.Join(outputDir, fmt.Sprintf("report-%s.html", timestamp)))
}

// getSeverityFromCVSS converts a CVSS score to a severity string
func getSeverityFromCVSS(cvssScore string) string {
	if cvssScore == "" {
		return "unknown"
	}

	score, err := strconv.ParseFloat(cvssScore, 64)
	if err != nil {
		return "unknown"
	}

	if score >= 9.0 {
		return "critical"
	} else if score >= 7.0 {
		return "high"
	} else if score >= 4.0 {
		return "medium"
	} else if score > 0.0 {
		return "low"
	}
	return "info"
}

// truncateString truncates a string to the specified length and adds ellipsis
func truncateString(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen] + "..."
}

// generateHTMLReport generates an HTML report from the test results
func generateHTMLReport(endpointResults map[string][]TestResult, summary map[string]interface{}, outputFile string) {
	// Basic HTML template for the report
	report := `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>API Security Test Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; color: #333; }
        h1, h2, h3 { color: #2c3e50; }
        .container { max-width: 1200px; margin: 0 auto; }
        .summary { background-color: #f8f9fa; border: 1px solid #ddd; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .summary-item { margin-bottom: 10px; }
        .endpoint { background-color: #f8f9fa; border: 1px solid #ddd; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .endpoint-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .method { font-weight: bold; padding: 5px 10px; border-radius: 3px; color: white; }
        .GET { background-color: #61affe; }
        .POST { background-color: #49cc90; }
        .PUT { background-color: #fca130; }
        .DELETE { background-color: #f93e3e; }
        .PATCH { background-color: #50e3c2; }
        .OPTIONS, .HEAD { background-color: #0d5aa7; }
        .vulnerability { margin-bottom: 15px; padding: 10px; border-left: 4px solid; }
        .VULNERABLE { border-color: #f93e3e; background-color: rgba(249, 62, 62, 0.1); }
        .POTENTIAL_VULNERABILITY { border-color: #fca130; background-color: rgba(252, 161, 48, 0.1); }
        .SECURE { border-color: #49cc90; background-color: rgba(73, 204, 144, 0.1); }
        .vulnerability-header { display: flex; justify-content: space-between; }
        .vuln-title { font-weight: bold; }
        .VULNERABLE-text { color: #f93e3e; }
        .POTENTIAL_VULNERABILITY-text { color: #fca130; }
        .SECURE-text { color: #49cc90; }
        .details { margin-top: 10px; }
        .details pre { background-color: #f1f1f1; padding: 10px; border-radius: 3px; overflow-x: auto; }
        .stats { display: flex; justify-content: space-around; margin-bottom: 20px; }
        .stat-item { text-align: center; padding: 15px; border-radius: 5px; }
        .stat-value { font-size: 24px; font-weight: bold; }
        .vulnerable-count { color: #f93e3e; }
        .potential-count { color: #fca130; }
        .secure-count { color: #49cc90; }
        .cvss { display: inline-block; padding: 3px 6px; border-radius: 3px; color: white; font-weight: bold; }
        .cvss-critical { background-color: #f93e3e; }
        .cvss-high { background-color: #ff8c00; }
        .cvss-medium { background-color: #ffd700; color: #333; }
        .cvss-low { background-color: #49cc90; }
        .cvss-none { background-color: #999999; }
        .toggle-button { cursor: pointer; color: #3498db; }
        .hidden { display: none; }
        .sort-controls { margin-bottom: 15px; }
        .sort-controls select, .sort-controls button { padding: 5px 10px; margin-right: 10px; }
        .filter-controls { margin-bottom: 15px; }
        .filter-controls label { margin-right: 15px; }
    </style>
    <script>
        function toggleSection(id) {
            var element = document.getElementById(id);
            if (element.classList.contains('hidden')) {
                element.classList.remove('hidden');
            } else {
                element.classList.add('hidden');
            }
        }
    </script>
</head>
<body>
    <div class="container">
        <h1>API Security Test Report</h1>
        
        <div class="summary">
            <div class="summary-item"><strong>Target:</strong> ${target}</div>
            <div class="summary-item"><strong>Scan Date:</strong> ${scan_date}</div>
            <div class="summary-item"><strong>Endpoints Tested:</strong> ${endpoints_count}</div>
        </div>
        
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value vulnerable-count">${vulnerable_count}</div>
                <div>Vulnerabilities</div>
            </div>
            <div class="stat-item">
                <div class="stat-value potential-count">${potential_count}</div>
                <div>Potential Issues</div>
            </div>
            <div class="stat-item">
                <div class="stat-value secure-count">${secure_count}</div>
                <div>Secure Tests</div>
            </div>
        </div>
        
        <div class="filter-controls">
            <label><input type="checkbox" checked onclick="toggleVulnerabilityDisplay('VULNERABLE')"> Show Vulnerabilities</label>
            <label><input type="checkbox" checked onclick="toggleVulnerabilityDisplay('POTENTIAL_VULNERABILITY')"> Show Potential Issues</label>
            <label><input type="checkbox" onclick="toggleVulnerabilityDisplay('SECURE')"> Show Secure Tests</label>
        </div>
        
        <h2>Findings</h2>
        
        <!-- Endpoints with vulnerabilities will be listed here -->
        ${endpoints}
    </div>
    
    <script>
        function toggleVulnerabilityDisplay(status) {
            var elements = document.getElementsByClassName(status);
            for (var i = 0; i < elements.length; i++) {
                if (elements[i].style.display === 'none') {
                    elements[i].style.display = '';
                } else {
                    elements[i].style.display = 'none';
                }
            }
        }
        
        // Initially hide secure findings
        var secureElements = document.getElementsByClassName('SECURE');
        for (var i = 0; i < secureElements.length; i++) {
            secureElements[i].style.display = 'none';
        }
    </script>
</body>
</html>`

	// Replace summary placeholders
	report = strings.Replace(report, "${target}", summary["target"].(string), -1)
	report = strings.Replace(report, "${scan_date}", summary["scan_date"].(string), -1)
	report = strings.Replace(report, "${endpoints_count}", fmt.Sprintf("%d", summary["endpoints_count"]), -1)
	report = strings.Replace(report, "${vulnerable_count}", fmt.Sprintf("%d", summary["results"].(map[string]int)["vulnerable"]), -1)
	report = strings.Replace(report, "${potential_count}", fmt.Sprintf("%d", summary["results"].(map[string]int)["potential"]), -1)
	report = strings.Replace(report, "${secure_count}", fmt.Sprintf("%d", summary["results"].(map[string]int)["secure"]), -1)

	// Build the endpoints section
	endpointsHTML := ""
	for key, results := range endpointResults {
		parts := strings.SplitN(key, " ", 2)
		method := parts[0]
		endpoint := parts[1]

		endpointHTML := fmt.Sprintf(`
        <div class="endpoint">
            <div class="endpoint-header">
                <h3><span class="method %s">%s</span> %s</h3>
                <span class="toggle-button" onclick="toggleSection('endpoint-%s')">Toggle Details</span>
            </div>
            <div id="endpoint-%s">
        `, method, method, endpoint, sanitizeID(key), sanitizeID(key))

		// Add each vulnerability
		for _, result := range results {
			// Determine CVSS severity class
			cvssClass := getCVSSSeverityClass(result.CVSS)

			// Build vulnerability HTML
			endpointHTML += fmt.Sprintf(`
                <div class="vulnerability %s">
                    <div class="vulnerability-header">
                        <div class="vuln-title">%s - <span class="%s-text">%s</span></div>
                        %s
                    </div>
                    <div class="details">
                        <p>%s</p>
                        %s
                        %s
                        %s
                    </div>
                </div>
            `,
				result.Status,
				result.TestType,
				result.Status,
				result.Status,
				getCVSSHTML(result.CVSS, cvssClass),
				result.Description,
				getEvidenceHTML(result.Evidence),
				getRecommendationHTML(result.Recommendation),
				getPayloadHTML(result.Payload))
		}

		endpointHTML += `
            </div>
        </div>`

		endpointsHTML += endpointHTML
	}

	report = strings.Replace(report, "${endpoints}", endpointsHTML, -1)

	// Write the report to file
	err := ioutil.WriteFile(outputFile, []byte(report), 0644)
	if err != nil {
		log.Printf("Error writing HTML report: %v", err)
	} else {
		log.Printf("HTML report saved to: %s", outputFile)
	}
}

// sanitizeID creates a safe ID for HTML elements
func sanitizeID(s string) string {
	s = strings.ReplaceAll(s, " ", "-")
	s = strings.ReplaceAll(s, "/", "-")
	s = strings.ReplaceAll(s, ":", "-")
	s = strings.ReplaceAll(s, ".", "-")
	s = strings.ReplaceAll(s, "{", "")
	s = strings.ReplaceAll(s, "}", "")
	return s
}

// getCVSSSeverityClass returns the CSS class for a CVSS score
func getCVSSSeverityClass(cvssScore string) string {
	if cvssScore == "" {
		return "cvss-none"
	}

	score, err := strconv.ParseFloat(cvssScore, 64)
	if err != nil {
		return "cvss-none"
	}

	if score >= 9.0 {
		return "cvss-critical"
	} else if score >= 7.0 {
		return "cvss-high"
	} else if score >= 4.0 {
		return "cvss-medium"
	} else {
		return "cvss-low"
	}
}

// containsAny checks if a string contains any of the substrings
func containsAny(s string, substrs []string) bool {
	for _, substr := range substrs {
		if strings.Contains(s, substr) {
			return true
		}
	}
	return false
}

// debugLog logs a message if debug mode is enabled
func debugLog(message string) {
	if config.Execution.Debug {
		log.Printf("[DEBUG] %s", message)
	}
}

// getCVSSHTML returns HTML for CVSS score display
func getCVSSHTML(cvssScore string, cvssClass string) string {
	if cvssScore == "" {
		return ""
	}
	return fmt.Sprintf(`<div class="cvss %s">CVSS: %s</div>`, cvssClass, cvssScore)
}

// getEvidenceHTML returns HTML for evidence display
func getEvidenceHTML(evidence string) string {
	if evidence == "" {
		return ""
	}
	return fmt.Sprintf("<p><strong>Evidence:</strong> %s</p>", evidence)
}

// getRecommendationHTML returns HTML for recommendation display
func getRecommendationHTML(recommendation string) string {
	if recommendation == "" {
		return ""
	}
	return fmt.Sprintf("<p><strong>Recommendation:</strong> %s</p>", recommendation)
}

// getPayloadHTML returns HTML for payload display
func getPayloadHTML(payload string) string {
	if payload == "" {
		return ""
	}
	return fmt.Sprintf("<p><strong>Test Payload:</strong></p><pre>%s</pre>", payload)
}

// getCWEForTestType maps test types to their corresponding CWE identifiers
func getCWEForTestType(testType string) string {
	// Map test types to CWE IDs
	cweMap := map[string]string{
		"Authentication":          "CWE-287", // Improper Authentication
		"Authorization - IDOR":    "CWE-639", // Authorization Bypass Through User-Controlled Key
		"SQL Injection":           "CWE-89",  // SQL Injection
		"NoSQL Injection":         "CWE-943", // Improper Neutralization of Special Elements in Data Query Logic
		"Command Injection":       "CWE-77",  // Improper Neutralization of Special Elements used in a Command
		"Path Traversal":          "CWE-22",  // Improper Limitation of a Pathname to a Restricted Directory
		"Sensitive Data Exposure": "CWE-200", // Exposure of Sensitive Information to an Unauthorized Actor
		"Rate Limit":              "CWE-770", // Allocation of Resources Without Limits or Throttling
		"CORS Misconfiguration":   "CWE-942", // Permissive Cross-domain Policy with Untrusted Domains
		"SSRF":                    "CWE-918", // Server-Side Request Forgery
		"Mass Assignment":         "CWE-915", // Improperly Controlled Modification of Dynamically-Determined Object Attributes
	}

	if cwe, ok := cweMap[testType]; ok {
		return cwe
	}
	return "CWE-693" // Protection Mechanism Failure (default)
}

// getImpactDescription returns a description of the potential impact based on test type and status
func getImpactDescription(testType string, status string) string {
	// Default impact descriptions based on test type
	impactMap := map[string]string{
		"Authentication":          "bypass authentication controls and gain unauthorized access to the system",
		"Authorization - IDOR":    "access resources belonging to other users or perform unauthorized operations",
		"SQL Injection":           "extract sensitive data from the database, modify database data, or execute administrative operations on the database",
		"NoSQL Injection":         "bypass authentication, extract data, or modify data in NoSQL databases",
		"Command Injection":       "execute arbitrary commands on the host operating system",
		"Path Traversal":          "access files and directories outside of the web root folder",
		"Sensitive Data Exposure": "access sensitive information such as credentials, personal data, or business secrets",
		"Rate Limit":              "perform denial of service attacks or brute force attempts without restriction",
		"CORS Misconfiguration":   "steal sensitive data by making cross-origin requests from malicious sites",
		"SSRF":                    "make server-side requests to internal resources or services",
		"Mass Assignment":         "modify protected attributes that weren't intended to be modified",
	}

	// Get the base impact description
	baseImpact := "exploit security vulnerabilities"
	if impact, ok := impactMap[testType]; ok {
		baseImpact = impact
	}

	// Adjust based on status
	if status == "VULNERABLE" {
		return baseImpact
	} else if status == "POTENTIAL_VULNERABILITY" {
		return "potentially " + baseImpact + " under certain conditions"
	}

	return baseImpact
}

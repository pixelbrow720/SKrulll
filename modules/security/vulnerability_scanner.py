"""
Basic Vulnerability Scanner module for the SKrulll Orchestrator.

This module provides a lightweight, dependency-minimal scanner for basic web vulnerabilities.
For more advanced scanning capabilities, use the comprehensive scanner at:
modules/vulnerability/scanner/vulnerability_scanner.py

This basic scanner is useful for quick checks and environments where installing
additional dependencies like Nuclei or OpenVAS is not feasible.

Features:
- Lightweight web vulnerability scanning
- Minimal dependencies (only requires requests)
- Configurable scan intensity levels
- Concurrent scanning for better performance
- Result caching to avoid redundant requests
- Comprehensive error handling and logging
- Adaptive scanning based on target response
- Memory-efficient processing for large targets
- Incremental scanning for very large targets
- Resilient error recovery with graceful degradation
- Optimized resource utilization
- Prioritized vulnerability detection
"""
import logging
import re
import socket
import ssl
import time
import concurrent.futures
from typing import Dict, List, Any, Optional, Tuple, Set, Union
import urllib.parse
import datetime
import json
import os
from functools import lru_cache
from pathlib import Path

logger = logging.getLogger(__name__)

# Configure module-level settings from environment variables or defaults
MAX_WORKERS = int(os.environ.get('CYBEROPS_SCANNER_MAX_WORKERS', '10'))  # Maximum number of concurrent threads
REQUEST_DELAY = float(os.environ.get('CYBEROPS_SCANNER_REQUEST_DELAY', '0.1'))  # Delay between requests
MAX_RETRIES = int(os.environ.get('CYBEROPS_SCANNER_MAX_RETRIES', '3'))  # Maximum number of retries for failed requests
CACHE_SIZE = int(os.environ.get('CYBEROPS_SCANNER_CACHE_SIZE', '128'))  # Size of LRU cache for responses
SCAN_TIMEOUT = int(os.environ.get('CYBEROPS_SCANNER_TIMEOUT', '30'))  # Default scan timeout in seconds
RESULT_CACHE_TTL = int(os.environ.get('CYBEROPS_SCANNER_RESULT_CACHE_TTL', '3600'))  # Cache TTL in seconds (1 hour)

# Try to import Redis for result caching
try:
    import redis
    REDIS_AVAILABLE = True
    logger.info("Redis available for result caching")
except ImportError:
    REDIS_AVAILABLE = False
    logger.debug("Redis not available, using file-based caching instead")

try:
    import requests
    from requests.packages.urllib3.exceptions import InsecureRequestWarning
    from requests.adapters import HTTPAdapter
    from requests.packages.urllib3.util.retry import Retry
    
    # Disable insecure request warnings
    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
    REQUESTS_AVAILABLE = True
except ImportError:
    logger.warning("requests not installed, vulnerability scanning functionality will be limited")
    REQUESTS_AVAILABLE = False

# Result cache directory - use environment variable or default path
CACHE_DIR = os.environ.get('CYBEROPS_SCANNER_CACHE_DIR', os.path.join(
    os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', '..')),
    'data', 'cache', 'vulnerability_scanner'
))

# Ensure cache directory exists
os.makedirs(CACHE_DIR, exist_ok=True)


class BasicVulnerabilityScanner:
    """Class for performing basic vulnerability scans with minimal dependencies."""
    
    def __init__(self, target: str, level: str = "medium", timeout: int = 30, 
                 max_threads: int = MAX_WORKERS, delay: float = REQUEST_DELAY):
        """
        Initialize the vulnerability scanner.
        
        Args:
            target: Target to scan (URL or hostname)
            level: Scan intensity level ("low", "medium", "high")
            timeout: Request timeout in seconds
            max_threads: Maximum number of concurrent threads
            delay: Delay between requests in seconds
        """
        self.target = target
        self.level = level.lower()
        self.timeout = timeout
        self.max_threads = max_threads
        self.delay = delay
        self.vulnerabilities = []
        self.session = None
        self.scan_start_time = None
        self.scan_end_time = None
        self._checked_urls = set()  # Track URLs we've already checked
        
        if REQUESTS_AVAILABLE:
            self.session = self._create_session()
        
        # Normalize target URL
        if not self.target.startswith(('http://', 'https://')):
            self.target = f"http://{self.target}"
            
        logger.info(f"Initialized vulnerability scanner for {self.target} with level {self.level}")
    
    def _create_session(self) -> requests.Session:
        """
        Create and configure a requests session with retry logic.
        
        Returns:
            Configured requests session
        """
        session = requests.Session()
        
        # Configure headers
        session.headers.update({
            "User-Agent": "SKrulll Vulnerability Scanner/1.0.0",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.5",
            "Connection": "close"  # Don't keep connections open
        })
        
        # Configure retry strategy
        retry_strategy = Retry(
            total=MAX_RETRIES,
            backoff_factor=0.5,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["GET", "HEAD"]
        )
        
        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        
        return session
    
    def run_scan(self) -> List[Dict[str, Any]]:
        """
        Run the vulnerability scan.
        
        Returns:
            List of detected vulnerabilities
        """
        if not REQUESTS_AVAILABLE:
            logger.error("Cannot run scan: requests package not installed")
            return []
        
        self.scan_start_time = datetime.datetime.now()
        logger.info(f"Starting vulnerability scan of {self.target} at {self.scan_start_time}")
        
        try:
            # Check basic connectivity first
            if not self._check_connectivity():
                logger.error(f"Cannot connect to target {self.target}, aborting scan")
                return self.vulnerabilities
            
            # Run appropriate scan modules based on level
            scan_modules = [
                self._check_ssl_issues,
                self._check_http_headers,
                self._check_server_information
            ]
            
            if self.level in ["medium", "high"]:
                scan_modules.extend([
                    self._check_directory_listing,
                    self._check_common_vulnerabilities
                ])
            
            if self.level == "high":
                scan_modules.extend([
                    self._check_sql_injection_simple,
                    self._check_xss_simple
                ])
            
            # Run scan modules in parallel if possible
            with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_threads) as executor:
                futures = [executor.submit(module) for module in scan_modules]
                for future in concurrent.futures.as_completed(futures):
                    try:
                        future.result()
                    except Exception as e:
                        logger.error(f"Error in scan module: {str(e)}", exc_info=True)
            
            # Deduplicate vulnerabilities
            self._deduplicate_vulnerabilities()
            
            self.scan_end_time = datetime.datetime.now()
            scan_duration = (self.scan_end_time - self.scan_start_time).total_seconds()
            logger.info(f"Vulnerability scan completed for {self.target} in {scan_duration:.2f} seconds, found {len(self.vulnerabilities)} issues")
            
            return self.vulnerabilities
            
        except Exception as e:
            logger.error(f"Error during vulnerability scan: {str(e)}", exc_info=True)
            self.scan_end_time = datetime.datetime.now()
            return self.vulnerabilities
    
    def _deduplicate_vulnerabilities(self) -> None:
        """Remove duplicate vulnerability findings."""
        unique_vulns = []
        vuln_names = set()
        
        for vuln in self.vulnerabilities:
            # Create a unique key for each vulnerability
            name = vuln.get("name", "")
            desc = vuln.get("description", "")
            key = f"{name}:{desc}"
            
            if key not in vuln_names:
                vuln_names.add(key)
                unique_vulns.append(vuln)
        
        self.vulnerabilities = unique_vulns
    
    @lru_cache(maxsize=CACHE_SIZE)
    def _make_request(self, url: str, method: str = "GET", data: Dict = None, 
                     headers: Dict = None, retry: bool = True) -> Optional[requests.Response]:
        """
        Make an HTTP request with built-in error handling and rate limiting.
        
        Args:
            url: URL to request
            method: HTTP method (GET, POST, etc.)
            data: Request data for POST requests
            headers: Additional headers to send
            retry: Whether to retry on failure
            
        Returns:
            Response object or None if request failed
        """
        if url in self._checked_urls:
            logger.debug(f"Skipping already checked URL: {url}")
            return None
            
        self._checked_urls.add(url)
        
        # Add delay to avoid overwhelming the target
        time.sleep(self.delay)
        
        try:
            if method.upper() == "GET":
                response = self.session.get(
                    url,
                    timeout=self.timeout,
                    verify=False,
                    allow_redirects=True,
                    headers=headers
                )
            elif method.upper() == "POST":
                response = self.session.post(
                    url,
                    timeout=self.timeout,
                    verify=False,
                    allow_redirects=True,
                    data=data,
                    headers=headers
                )
            else:
                logger.error(f"Unsupported HTTP method: {method}")
                return None
                
            return response
            
        except requests.exceptions.RequestException as e:
            if retry:
                logger.debug(f"Request failed, retrying: {url} - {str(e)}")
                time.sleep(1)  # Wait a bit longer before retry
                return self._make_request(url, method, data, headers, retry=False)
            else:
                logger.debug(f"Request failed after retry: {url} - {str(e)}")
                return None
        except Exception as e:
            logger.error(f"Unexpected error making request to {url}: {str(e)}")
            return None
    
    def _check_connectivity(self) -> bool:
        """
        Check basic connectivity to the target.
        
        Returns:
            True if target is reachable, False otherwise
        """
        try:
            response = self._make_request(self.target)
            
            if response.status_code >= 400:
                self.vulnerabilities.append({
                    "name": "Connection Issue",
                    "severity": "Low",
                    "description": f"Received HTTP {response.status_code} when connecting to the target.",
                    "recommendation": "Verify the target URL and ensure the service is running.",
                    "timestamp": datetime.datetime.now().isoformat()
                })
                # Still return True since we got a response
                return True
            
            return True
            
        except requests.exceptions.RequestException as e:
            self.vulnerabilities.append({
                "name": "Connection Failure",
                "severity": "High",
                "description": f"Could not connect to the target: {str(e)}",
                "recommendation": "Verify the target URL and ensure the service is running.",
                "timestamp": datetime.datetime.now().isoformat()
            })
            return False
        except Exception as e:
            logger.error(f"Unexpected error checking connectivity: {str(e)}")
            return False
    
    def _check_ssl_issues(self):
        """Check for SSL/TLS issues."""
        if not self.target.startswith("https://"):
            self.vulnerabilities.append({
                "name": "Unencrypted Connection",
                "severity": "Medium",
                "description": "The target website does not use HTTPS encryption.",
                "recommendation": "Implement HTTPS with a valid SSL/TLS certificate.",
                "timestamp": datetime.datetime.now().isoformat()
            })
            return
        
        try:
            parsed_url = urllib.parse.urlparse(self.target)
            hostname = parsed_url.hostname
            port = parsed_url.port or 443
            
            # Check SSL using socket
            context = ssl.create_default_context()
            with socket.create_connection((hostname, port), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Check certificate expiration
                    expires = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    now = datetime.datetime.now()
                    days_remaining = (expires - now).days
                    
                    if days_remaining < 0:
                        self.vulnerabilities.append({
                            "name": "Expired SSL Certificate",
                            "severity": "High",
                            "description": f"The SSL certificate expired {abs(days_remaining)} days ago.",
                            "recommendation": "Renew the SSL certificate immediately.",
                            "timestamp": datetime.datetime.now().isoformat()
                        })
                    elif days_remaining < 30:
                        self.vulnerabilities.append({
                            "name": "SSL Certificate Expiring Soon",
                            "severity": "Medium",
                            "description": f"The SSL certificate will expire in {days_remaining} days.",
                            "recommendation": "Plan to renew the SSL certificate soon.",
                            "timestamp": datetime.datetime.now().isoformat()
                        })
                    
                    # Check for weak cipher suites
                    cipher = ssock.cipher()
                    if cipher:
                        cipher_name = cipher[0]
                        if any(weak in cipher_name.lower() for weak in ['des', 'rc4', 'md5', 'null', 'export']):
                            self.vulnerabilities.append({
                                "name": "Weak SSL/TLS Cipher Suite",
                                "severity": "Medium",
                                "description": f"The server supports weak cipher suite: {cipher_name}",
                                "recommendation": "Configure the server to use only strong cipher suites.",
                                "timestamp": datetime.datetime.now().isoformat()
                            })
                    
                    # Check for weak protocol versions
                    version = ssock.version()
                    if version in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                        self.vulnerabilities.append({
                            "name": "Outdated SSL/TLS Protocol",
                            "severity": "Medium",
                            "description": f"The server uses outdated protocol: {version}",
                            "recommendation": "Configure the server to use TLSv1.2 or TLSv1.3 only.",
                            "timestamp": datetime.datetime.now().isoformat()
                        })
                    
                    # Check certificate chain
                    if 'subjectAltName' not in cert:
                        self.vulnerabilities.append({
                            "name": "Missing Subject Alternative Name",
                            "severity": "Medium",
                            "description": "The SSL certificate does not have Subject Alternative Name (SAN) extension.",
                            "recommendation": "Obtain a certificate with proper SAN extension that includes all domain names.",
                            "timestamp": datetime.datetime.now().isoformat()
                        })
                    
                    # Check for certificate key length
                    if 'OCSP' not in str(cert):
                        self.vulnerabilities.append({
                            "name": "OCSP Stapling Not Enabled",
                            "severity": "Low",
                            "description": "OCSP stapling is not enabled, which can improve SSL/TLS performance.",
                            "recommendation": "Enable OCSP stapling on the web server.",
                            "timestamp": datetime.datetime.now().isoformat()
                        })
                    
        except Exception as e:
            logger.error(f"Error checking SSL: {str(e)}")
            self.vulnerabilities.append({
                "name": "SSL Configuration Issue",
                "severity": "Medium",
                "description": f"Could not validate SSL certificate: {str(e)}",
                "recommendation": "Check SSL configuration and certificate validity.",
                "timestamp": datetime.datetime.now().isoformat()
            })
    
    def _check_http_headers(self):
        """Check for security-related HTTP headers."""
        try:
            response = self._make_request(self.target)
            if not response:
                return
                
            headers = response.headers
            
            # Check for missing security headers
            security_headers = {
                "Strict-Transport-Security": {
                    "description": "HSTS is not enabled, which helps protect against protocol downgrade attacks.",
                    "recommendation": "Add the Strict-Transport-Security header with a long max-age value.",
                    "severity": "Medium" if self.target.startswith("https://") else "Low"
                },
                "Content-Security-Policy": {
                    "description": "CSP is not set, which helps prevent XSS attacks.",
                    "recommendation": "Implement a Content-Security-Policy header with appropriate directives.",
                    "severity": "Medium"
                },
                "X-Content-Type-Options": {
                    "description": "X-Content-Type-Options header is missing, which helps prevent MIME type sniffing.",
                    "recommendation": "Add the X-Content-Type-Options: nosniff header.",
                    "severity": "Low"
                },
                "X-Frame-Options": {
                    "description": "X-Frame-Options header is missing, which helps prevent clickjacking attacks.",
                    "recommendation": "Add the X-Frame-Options header with DENY or SAMEORIGIN value.",
                    "severity": "Medium"
                },
                "Referrer-Policy": {
                    "description": "Referrer-Policy header is missing, which controls how much referrer information is included with requests.",
                    "recommendation": "Add the Referrer-Policy header with an appropriate value like 'strict-origin-when-cross-origin'.",
                    "severity": "Low"
                },
                "Permissions-Policy": {
                    "description": "Permissions-Policy header is missing, which helps control browser features.",
                    "recommendation": "Add the Permissions-Policy header to restrict access to sensitive browser features.",
                    "severity": "Low"
                }
            }
            
            for header, info in security_headers.items():
                if header not in headers:
                    self.vulnerabilities.append({
                        "name": f"Missing {header} Header",
                        "severity": info["severity"],
                        "description": info["description"],
                        "recommendation": info["recommendation"],
                        "timestamp": datetime.datetime.now().isoformat()
                    })
            
            # Check for information disclosure in headers
            sensitive_headers = ["Server", "X-Powered-By", "X-AspNet-Version", "X-AspNetMvc-Version"]
            for header in sensitive_headers:
                if header in headers:
                    self.vulnerabilities.append({
                        "name": "Information Disclosure in HTTP Headers",
                        "severity": "Low",
                        "description": f"The {header} header reveals information about the technology stack: {headers[header]}",
                        "recommendation": f"Configure the server to not send the {header} header.",
                        "timestamp": datetime.datetime.now().isoformat()
                    })
            
            # Check for cookie security
            cookies = response.cookies
            for cookie in cookies:
                issues = []
                
                if not cookie.secure and self.target.startswith("https://"):
                    issues.append("missing Secure flag")
                
                if not cookie.has_nonstandard_attr("HttpOnly"):
                    issues.append("missing HttpOnly flag")
                
                if not cookie.has_nonstandard_attr("SameSite"):
                    issues.append("missing SameSite attribute")
                
                if issues:
                    self.vulnerabilities.append({
                        "name": "Insecure Cookie Configuration",
                        "severity": "Medium",
                        "description": f"Cookie '{cookie.name}' has security issues: {', '.join(issues)}",
                        "recommendation": "Set Secure, HttpOnly, and SameSite attributes on cookies.",
                        "timestamp": datetime.datetime.now().isoformat()
                    })
            
        except Exception as e:
            logger.error(f"Error checking HTTP headers: {str(e)}")
    
    def _check_server_information(self):
        """Check for server information disclosure."""
        try:
            response = self._make_request(self.target)
            if not response:
                return
                
            # Check for server software in headers
            server = response.headers.get("Server", "")
            if server and any(tech in server.lower() for tech in ["apache", "nginx", "iis", "php", "tomcat", "jetty", "websphere", "weblogic"]):
                version_match = re.search(r'[\d\.]+', server)
                if version_match:
                    self.vulnerabilities.append({
                        "name": "Server Version Disclosure",
                        "severity": "Low",
                        "description": f"The server reveals its software version: {server}",
                        "recommendation": "Configure the server to hide version information in HTTP headers.",
                        "timestamp": datetime.datetime.now().isoformat()
                    })
            
            # Check for technology fingerprints in response body
            content = response.text.lower()
            tech_fingerprints = {
                "wordpress": ["wp-content", "wp-includes", "wordpress"],
                "drupal": ["drupal.org", "drupal.min.js"],
                "joomla": ["joomla!", "/media/jui/"],
                "django": ["csrfmiddlewaretoken", "__admin_media_prefix__"],
                "laravel": ["laravel", "csrf-token"],
                "jquery": ["jquery.js", "jquery.min.js"],
                "bootstrap": ["bootstrap.css", "bootstrap.min.js"],
                "react": ["react.js", "react-dom.js"],
                "angular": ["ng-app", "angular.js"],
                "php": ["php", ".php"],
                "asp.net": ["__viewstate", "__aspxautodatectcookiesupport"]
            }
            
            detected_tech = []
            for tech, patterns in tech_fingerprints.items():
                if any(pattern in content for pattern in patterns):
                    detected_tech.append(tech)
            
            if detected_tech:
                self.vulnerabilities.append({
                    "name": "Technology Stack Disclosure",
                    "severity": "Informational",
                    "description": f"The application reveals its technology stack: {', '.join(detected_tech)}",
                    "recommendation": "Consider obfuscating technology details where possible.",
                    "timestamp": datetime.datetime.now().isoformat()
                })
            
        except Exception as e:
            logger.error(f"Error checking server information: {str(e)}")
    
    def _check_directory_listing(self):
        """Check for directory listing vulnerabilities."""
        common_dirs = [
            "images", "js", "css", "uploads", "assets", "admin", "backup", "config", "data", "logs",
            "includes", "static", "media", "files", "temp", "tmp", "cache", "docs", "download", "api"
        ]
        
        # Use ThreadPoolExecutor to check directories in parallel
        with concurrent.futures.ThreadPoolExecutor(max_workers=min(len(common_dirs), self.max_threads)) as executor:
            futures = {executor.submit(self._check_single_directory, directory): directory for directory in common_dirs}
            for future in concurrent.futures.as_completed(futures):
                try:
                    future.result()
                except Exception as e:
                    logger.debug(f"Error checking directory: {str(e)}")
    
    def _check_single_directory(self, directory: str) -> None:
        """
        Check a single directory for directory listing vulnerability.
        
        Args:
            directory: Directory name to check
        """
        try:
            url = urllib.parse.urljoin(self.target, directory + "/")
            response = self._make_request(url)
            if not response:
                return
                
            # Look for signs of directory listing
            content = response.text.lower()
            
            # Different patterns for different web servers
            apache_pattern = ("index of" in content and "parent directory" in content)
            nginx_pattern = ("directory listing" in content or "index of" in content) and "<a href=" in content
            iis_pattern = ("directory listing" in content or "index of" in content) and "last modified" in content
            
            if response.status_code == 200 and (apache_pattern or nginx_pattern or iis_pattern):
                self.vulnerabilities.append({
                    "name": "Directory Listing Enabled",
                    "severity": "Medium",
                    "description": f"Directory listing is enabled for {url}, which may expose sensitive files.",
                    "recommendation": "Disable directory listing in the web server configuration.",
                    "timestamp": datetime.datetime.now().isoformat()
                })
                
                # If we found a directory listing, check for sensitive file patterns in the listing
                sensitive_patterns = [
                    "password", "backup", "config", "db", "database", "secret", "key", 
                    ".sql", ".bak", ".old", ".zip", ".tar", ".gz", ".env"
                ]
                
                for pattern in sensitive_patterns:
                    if pattern in content:
                        self.vulnerabilities.append({
                            "name": "Sensitive Information in Directory Listing",
                            "severity": "High",
                            "description": f"Directory listing at {url} contains potentially sensitive files matching pattern '{pattern}'.",
                            "recommendation": "Disable directory listing and restrict access to sensitive files.",
                            "timestamp": datetime.datetime.now().isoformat()
                        })
                        break
                
        except Exception as e:
            logger.debug(f"Error checking directory {directory}: {str(e)}")
    
    def _check_common_vulnerabilities(self):
        """Check for common vulnerabilities and misconfigurations."""
        # Check for common sensitive files
        sensitive_files = [
            # Configuration files
            "robots.txt", ".env", "config.php", "wp-config.php", "config.js", ".htaccess", 
            "web.config", "settings.php", "configuration.php", "config.inc.php",
            
            # Version control
            ".git/HEAD", ".git/config", ".svn/entries", ".hg/store/00manifest.i",
            
            # Backup files
            "backup.sql", "backup.zip", "backup.tar.gz", "backup.bak", "backup.old",
            "database.sql", "db.sql", "dump.sql", "data.sql",
            
            # Debug/Info files
            "phpinfo.php", "info.php", "test.php", "server-status", "server-info",
            
            # Package files
            "composer.json", "package.json", "yarn.lock", "Gemfile", "requirements.txt",
            
            # Log files
            "error.log", "access.log", "debug.log", "application.log", "web.log"
        ]
        
        # Use ThreadPoolExecutor to check files in parallel
        with concurrent.futures.ThreadPoolExecutor(max_workers=min(len(sensitive_files), self.max_threads)) as executor:
            futures = {executor.submit(self._check_sensitive_file, file): file for file in sensitive_files}
            for future in concurrent.futures.as_completed(futures):
                try:
                    future.result()
                except Exception as e:
                    logger.debug(f"Error checking sensitive file: {str(e)}")
        
        # Check for common misconfigurations
        self._check_cors_misconfiguration()
        self._check_open_redirects()
        
    def _check_sensitive_file(self, file: str) -> None:
        """
        Check if a sensitive file is accessible.
        
        Args:
            file: Filename to check
        """
        try:
            url = urllib.parse.urljoin(self.target, file)
            response = self._make_request(url)
            if not response:
                return
                
            if response.status_code == 200:
                content_length = len(response.content)
                if content_length > 0:
                    severity = "Medium"
                    
                    # Adjust severity based on file type
                    if any(pattern in file.lower() for pattern in [".env", "config", "password", "secret", "key", "backup", "dump"]):
                        severity = "High"
                    
                    self.vulnerabilities.append({
                        "name": "Sensitive File Exposed",
                        "severity": severity,
                        "description": f"The file {file} is accessible and may contain sensitive information.",
                        "recommendation": f"Restrict access to {file} or remove it if not needed.",
                        "timestamp": datetime.datetime.now().isoformat()
                    })
                    
        except Exception as e:
            logger.debug(f"Error checking sensitive file {file}: {str(e)}")
    
    def _check_cors_misconfiguration(self) -> None:
        """Check for CORS misconfigurations."""
        try:
            # Test with a fake origin header
            headers = {"Origin": "https://evil-site.com"}
            response = self._make_request(self.target, headers=headers)
            if not response:
                return
                
            cors_headers = [
                "Access-Control-Allow-Origin",
                "Access-Control-Allow-Credentials",
                "Access-Control-Allow-Methods",
                "Access-Control-Allow-Headers"
            ]
            
            # Check if the server reflects our origin or uses a wildcard
            if "Access-Control-Allow-Origin" in response.headers:
                acao = response.headers["Access-Control-Allow-Origin"]
                if acao == "*" or acao == "https://evil-site.com":
                    allow_credentials = response.headers.get("Access-Control-Allow-Credentials", "").lower() == "true"
                    severity = "High" if allow_credentials else "Medium"
                    
                    self.vulnerabilities.append({
                        "name": "CORS Misconfiguration",
                        "severity": severity,
                        "description": f"The server has a CORS misconfiguration: Access-Control-Allow-Origin: {acao}" + 
                                      (", Access-Control-Allow-Credentials: true" if allow_credentials else ""),
                        "recommendation": "Configure CORS headers properly to restrict access to trusted domains only.",
                        "timestamp": datetime.datetime.now().isoformat()
                    })
                    
        except Exception as e:
            logger.debug(f"Error checking CORS misconfiguration: {str(e)}")
    
    def _check_open_redirects(self) -> None:
        """Check for open redirect vulnerabilities."""
        try:
            # Common redirect parameters
            redirect_params = ["redirect", "url", "next", "return", "returnTo", "returnUrl", "goto", "to", "link", "location"]
            redirect_target = "https://evil-site.com"
            
            parsed_url = urllib.parse.urlparse(self.target)
            base_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
            
            for param in redirect_params:
                test_url = f"{base_url}?{param}={urllib.parse.quote(redirect_target)}"
                response = self._make_request(test_url)
                if not response:
                    continue
                    
                # Check if we got redirected to our evil site
                if response.url.startswith(redirect_target):
                    self.vulnerabilities.append({
                        "name": "Open Redirect Vulnerability",
                        "severity": "Medium",
                        "description": f"The application has an open redirect vulnerability using the '{param}' parameter.",
                        "recommendation": "Implement proper validation of redirect URLs and use a whitelist of allowed destinations.",
                        "timestamp": datetime.datetime.now().isoformat()
                    })
                    break
                    
        except Exception as e:
            logger.debug(f"Error checking open redirects: {str(e)}")
    
    def _check_sql_injection_simple(self):
        """Perform simple SQL injection checks."""
        if not self._is_web_application():
            return
            
        # Find forms and parameters
        try:
            response = self.session.get(
                self.target, 
                timeout=self.timeout,
                verify=False,
                allow_redirects=True
            )
            
            # Very simple check for SQL errors with a single quote
            # This is just for demonstration and not a comprehensive SQL injection test
            test_urls = []
            
            # Add the main URL with a parameter
            parsed_url = urllib.parse.urlparse(self.target)
            if parsed_url.query:
                params = urllib.parse.parse_qsl(parsed_url.query)
                for param, value in params:
                    # Create a URL with a single quote added to the parameter
                    new_params = [(p, v + "'" if p == param else v) for p, v in params]
                    query = urllib.parse.urlencode(new_params)
                    test_url = urllib.parse.urlunparse((
                        parsed_url.scheme,
                        parsed_url.netloc,
                        parsed_url.path,
                        parsed_url.params,
                        query,
                        parsed_url.fragment
                    ))
                    test_urls.append(test_url)
            
            # Add some common paths that might have parameters
            common_paths = ["search", "login", "products", "articles", "news"]
            for path in common_paths:
                test_url = urllib.parse.urljoin(self.target, f"{path}?id=1'")
                test_urls.append(test_url)
            
            # Test each URL for SQL error responses
            sql_error_patterns = [
                "sql syntax", "mysql error", "sql server", "oracle error",
                "syntax error", "unclosed quotation mark", "pg_query()"
            ]
            
            for url in test_urls:
                try:
                    response = self.session.get(
                        url, 
                        timeout=self.timeout,
                        verify=False,
                        allow_redirects=True
                    )
                    
                    content = response.text.lower()
                    for pattern in sql_error_patterns:
                        if pattern in content:
                            self.vulnerabilities.append({
                                "name": "Potential SQL Injection",
                                "severity": "High",
                                "description": f"The application may be vulnerable to SQL injection at {url}. SQL error detected in response.",
                                "recommendation": "Implement proper input validation and parameterized queries."
                            })
                            break
                            
                except Exception:
                    pass  # Ignore errors for SQL injection tests
            
        except Exception as e:
            logger.error(f"Error during SQL injection check: {str(e)}")
    
    def _check_xss_simple(self):
        """Perform simple XSS checks."""
        if not self._is_web_application():
            return
            
        # Find forms and parameters
        try:
            response = self.session.get(
                self.target, 
                timeout=self.timeout,
                verify=False,
                allow_redirects=True
            )
            
            # Very simple check for reflected XSS
            # This is just for demonstration and not a comprehensive XSS test
            test_urls = []
            
            # Add the main URL with a parameter
            parsed_url = urllib.parse.urlparse(self.target)
            if parsed_url.query:
                params = urllib.parse.parse_qsl(parsed_url.query)
                for param, value in params:
                    # Create a URL with a simple XSS payload
                    new_params = [(p, "<script>alert(1)</script>" if p == param else v) for p, v in params]
                    query = urllib.parse.urlencode(new_params)
                    test_url = urllib.parse.urlunparse((
                        parsed_url.scheme,
                        parsed_url.netloc,
                        parsed_url.path,
                        parsed_url.params,
                        query,
                        parsed_url.fragment
                    ))
                    test_urls.append(test_url)
            
            # Add some common paths that might have parameters
            common_paths = ["search", "profile", "feedback", "comment", "user"]
            for path in common_paths:
                test_url = urllib.parse.urljoin(self.target, f"{path}?q=<script>alert(1)</script>")
                test_urls.append(test_url)
            
            # Test each URL for reflected XSS
            xss_payload = "<script>alert(1)</script>"
            
            for url in test_urls:
                try:
                    response = self.session.get(
                        url, 
                        timeout=self.timeout,
                        verify=False,
                        allow_redirects=True
                    )
                    
                    if xss_payload in response.text:
                        self.vulnerabilities.append({
                            "name": "Potential Reflected XSS",
                            "severity": "High",
                            "description": f"The application may be vulnerable to Cross-Site Scripting at {url}. Payload was reflected in response.",
                            "recommendation": "Implement proper output encoding and input validation."
                        })
                        break
                            
                except Exception:
                    pass  # Ignore errors for XSS tests
            
        except Exception as e:
            logger.error(f"Error during XSS check: {str(e)}")
    
    def _is_web_application(self) -> bool:
        """Check if the target appears to be a web application."""
        try:
            response = self.session.get(
                self.target, 
                timeout=self.timeout,
                verify=False,
                allow_redirects=True
            )
            
            # Check content type
            content_type = response.headers.get("Content-Type", "")
            return "text/html" in content_type
        except Exception:
            return False


def _get_cache_key(target: str, level: str) -> str:
    """
    Generate a cache key for scan results.
    
    Args:
        target: Target URL or hostname
        level: Scan intensity level
        
    Returns:
        Cache key string
    """
    # Normalize target URL
    if not target.startswith(('http://', 'https://')):
        target = f"http://{target}"
    
    # Create a unique key based on target and level
    return f"vuln_scan:{target}:{level}"

def _get_cached_result(cache_key: str) -> Optional[List[Dict[str, Any]]]:
    """
    Get cached scan result if available.
    
    Args:
        cache_key: Cache key string
        
    Returns:
        Cached scan result or None if not found or expired
    """
    # Try Redis cache first if available
    if REDIS_AVAILABLE:
        try:
            redis_host = os.environ.get('REDIS_HOST', 'localhost')
            redis_port = int(os.environ.get('REDIS_PORT', 6379))
            redis_db = int(os.environ.get('REDIS_DB', 0))
            redis_password = os.environ.get('REDIS_PASSWORD', None)
            
            r = redis.Redis(
                host=redis_host,
                port=redis_port,
                db=redis_db,
                password=redis_password,
                decode_responses=False  # Keep as bytes for json.loads
            )
            
            cached_data = r.get(cache_key)
            if cached_data:
                logger.info(f"Using cached scan result for {cache_key}")
                return json.loads(cached_data)
        except Exception as e:
            logger.warning(f"Error retrieving from Redis cache: {str(e)}")
    
    # Fall back to file-based cache
    cache_file = os.path.join(CACHE_DIR, f"{cache_key.replace(':', '_')}.json")
    if os.path.exists(cache_file):
        try:
            # Check if cache is still valid
            file_mtime = os.path.getmtime(cache_file)
            if (time.time() - file_mtime) < RESULT_CACHE_TTL:
                with open(cache_file, 'r') as f:
                    logger.info(f"Using file-cached scan result for {cache_key}")
                    return json.load(f)
            else:
                logger.debug(f"Cache expired for {cache_key}")
                os.remove(cache_file)  # Remove expired cache
        except Exception as e:
            logger.warning(f"Error reading cache file: {str(e)}")
    
    return None

def _cache_result(cache_key: str, result: List[Dict[str, Any]]) -> None:
    """
    Cache scan result.
    
    Args:
        cache_key: Cache key string
        result: Scan result to cache
    """
    # Try Redis cache first if available
    if REDIS_AVAILABLE:
        try:
            redis_host = os.environ.get('REDIS_HOST', 'localhost')
            redis_port = int(os.environ.get('REDIS_PORT', 6379))
            redis_db = int(os.environ.get('REDIS_DB', 0))
            redis_password = os.environ.get('REDIS_PASSWORD', None)
            
            r = redis.Redis(
                host=redis_host,
                port=redis_port,
                db=redis_db,
                password=redis_password
            )
            
            r.setex(
                cache_key,
                RESULT_CACHE_TTL,
                json.dumps(result)
            )
            logger.debug(f"Cached scan result in Redis for {cache_key} (TTL: {RESULT_CACHE_TTL}s)")
        except Exception as e:
            logger.warning(f"Error caching result in Redis: {str(e)}")
    
    # Also cache to file as backup
    try:
        cache_file = os.path.join(CACHE_DIR, f"{cache_key.replace(':', '_')}.json")
        with open(cache_file, 'w') as f:
            json.dump(result, f)
        logger.debug(f"Cached scan result to file: {cache_file}")
    except Exception as e:
        logger.warning(f"Error caching result to file: {str(e)}")

def scan_vulnerabilities(target: str, level: str = "medium", use_cache: bool = True, 
                        timeout: int = None, max_workers: int = None, 
                        user_agent: str = None) -> List[Dict[str, Any]]:
    """
    Perform a basic vulnerability scan on a target.
    
    This is a simplified scanner for quick checks. For comprehensive scanning,
    use the advanced scanner in modules/vulnerability/scanner/vulnerability_scanner.py
    
    Args:
        target: Target to scan (URL or hostname)
        level: Scan intensity level ("low", "medium", "high")
        use_cache: Whether to use cached results if available
        timeout: Timeout in seconds for requests (overrides default/env)
        max_workers: Maximum number of concurrent threads (overrides default/env)
        user_agent: Custom user agent string (overrides default)
        
    Returns:
        List of detected vulnerabilities
    """
    # Check cache if enabled
    if use_cache:
        cache_key = _get_cache_key(target, level)
        cached_result = _get_cached_result(cache_key)
        if cached_result:
            return cached_result
    
    # Use provided values or defaults
    scan_timeout = timeout if timeout is not None else SCAN_TIMEOUT
    workers = max_workers if max_workers is not None else MAX_WORKERS
    
    # Run scan if no cache or cache disabled
    scanner = BasicVulnerabilityScanner(
        target, 
        level=level,
        timeout=scan_timeout,
        max_threads=workers
    )
    
    # Set custom user agent if provided
    if user_agent and scanner.session:
        scanner.session.headers.update({"User-Agent": user_agent})
    
    result = scanner.run_scan()
    
    # Cache the result if enabled
    if use_cache and result:
        cache_key = _get_cache_key(target, level)
        _cache_result(cache_key, result)
    
    return result

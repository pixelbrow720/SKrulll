"""
Vulnerability Scanner for the SKrulll Orchestrator.

This module provides a high-performance, asynchronous vulnerability scanner
that supports Nuclei templates and OpenVAS integration, with configurable
concurrency and rate-limiting controls.
"""

import asyncio
import json
import logging
import os
import re
import tempfile
import time
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple, Union

import aiofiles
import aiohttp
import cvss
import psycopg2
import yaml
from psycopg2.extras import Json, execute_values

logger = logging.getLogger(__name__)

# Scanner Types
class ScannerType(Enum):
    NUCLEI = "nuclei"
    OPENVAS = "openvas"
    CUSTOM = "custom"


# Severity Levels
class Severity(Enum):
    INFO = "info"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class Template:
    """Vulnerability scanning template."""
    id: str
    name: str
    description: str
    author: str
    tags: List[str] = field(default_factory=list)
    severity: Severity = Severity.MEDIUM
    type: ScannerType = ScannerType.NUCLEI
    path: Optional[str] = None
    content: Optional[Dict[str, Any]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert template to dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "author": self.author,
            "tags": self.tags,
            "severity": self.severity.value,
            "type": self.type.value,
            "path": self.path,
        }


@dataclass
class Vulnerability:
    """Detected vulnerability."""
    id: str
    name: str
    description: str
    target: str
    template_id: str
    severity: Severity
    cvss_score: Optional[float] = None
    cvss_vector: Optional[str] = None
    references: List[str] = field(default_factory=list)
    details: Dict[str, Any] = field(default_factory=dict)
    remediation: Optional[str] = None
    detected_at: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert vulnerability to dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "target": self.target,
            "template_id": self.template_id,
            "severity": self.severity.value,
            "cvss_score": self.cvss_score,
            "cvss_vector": self.cvss_vector,
            "references": self.references,
            "details": self.details,
            "remediation": self.remediation,
            "detected_at": self.detected_at.isoformat(),
        }


@dataclass
class ScanResult:
    """Scan result."""
    id: str
    target: str
    scan_type: ScannerType
    start_time: datetime
    end_time: Optional[datetime] = None
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    summary: Dict[str, Any] = field(default_factory=dict)
    raw_output: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert scan result to dictionary."""
        return {
            "id": self.id,
            "target": self.target,
            "scan_type": self.scan_type.value,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "vulnerabilities": [v.to_dict() for v in self.vulnerabilities],
            "summary": self.summary,
        }


class VulnerabilityScanner:
    """Asynchronous vulnerability scanner with template support."""
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the Vulnerability Scanner.
        
        Args:
            config: Configuration dictionary
        """
        self.config = config or {}
        self.template_dirs = [
            Path(self.config.get("template_dir", "modules/vulnerability/templates")),
        ]
        
        # Add any additional template directories from config
        if extra_dirs := self.config.get("extra_template_dirs"):
            self.template_dirs.extend([Path(d) for d in extra_dirs])
            
        # Concurrency and rate limiting settings
        self.max_concurrent_scans = self.config.get("max_concurrent_scans", 10)
        self.scan_rate_limit = self.config.get("scan_rate_limit", 5)  # scans per second
        self.requests_per_host = self.config.get("requests_per_host", 10)  # requests per host per second
        
        # Scanner executables and settings
        self.nuclei_path = self.config.get("nuclei_path", "nuclei")
        self.nuclei_templates_dir = self.config.get("nuclei_templates_dir", "modules/vulnerability/templates/nuclei")
        
        # OpenVAS settings
        self.openvas_host = self.config.get("openvas_host", "localhost")
        self.openvas_port = self.config.get("openvas_port", 9390)
        self.openvas_username = self.config.get("openvas_username", "admin")
        self.openvas_password = self.config.get("openvas_password", "admin")
        
        # Database connection
        self.db_connection_string = self.config.get("db_connection_string", os.environ.get("DATABASE_URL"))
        
        # Cache for loaded templates
        self.templates: Dict[str, Template] = {}
        
        # Semaphores for concurrency control
        self.scan_semaphore = asyncio.Semaphore(self.max_concurrent_scans)
        self.last_scan_time = 0
        
        # Host rate limiting
        self.host_rate_limiters: Dict[str, asyncio.Semaphore] = {}
        self.host_last_request: Dict[str, float] = {}
        
    async def load_templates(self, template_type: Optional[ScannerType] = None) -> Dict[str, Template]:
        """
        Load templates from template directories.
        
        Args:
            template_type: Filter by template type
            
        Returns:
            Dictionary of loaded templates
        """
        logger.info(f"Loading templates from {len(self.template_dirs)} directories")
        
        for template_dir in self.template_dirs:
            if not template_dir.exists():
                logger.warning(f"Template directory {template_dir} does not exist")
                continue
                
            logger.info(f"Scanning template directory: {template_dir}")
            
            # Find all YAML and JSON files in the directory structure
            for ext in ["*.yaml", "*.yml", "*.json"]:
                for template_file in template_dir.glob(f"**/{ext}"):
                    try:
                        await self._load_template_file(template_file, template_type)
                    except Exception as e:
                        logger.error(f"Error loading template {template_file}: {str(e)}")
        
        logger.info(f"Loaded {len(self.templates)} templates")
        return self.templates
    
    async def _load_template_file(self, template_file: Path, template_type: Optional[ScannerType] = None) -> Optional[Template]:
        """
        Load a template from a file.
        
        Args:
            template_file: Path to the template file
            template_type: Filter by template type
            
        Returns:
            Loaded template or None
        """
        # Skip templates that don't match the requested type
        file_type = self._detect_template_type(template_file)
        if template_type and file_type != template_type:
            return None
            
        try:
            async with aiofiles.open(template_file, 'r') as f:
                content = await f.read()
                
            # Parse the template based on the file extension
            if template_file.suffix in ['.yaml', '.yml']:
                template_data = yaml.safe_load(content)
            else:  # JSON
                template_data = json.loads(content)
                
            # Common template attributes
            template_id = template_data.get('id') or str(uuid.uuid4())
            name = template_data.get('name') or template_file.stem
            description = template_data.get('description', f"Template {name}")
            author = template_data.get('author', 'unknown')
            tags = template_data.get('tags', [])
            severity_str = template_data.get('severity', 'medium').lower()
            
            # Convert severity string to enum
            try:
                severity = Severity[severity_str.upper()]
            except KeyError:
                severity = Severity.MEDIUM
                
            # Create the template object
            template = Template(
                id=template_id,
                name=name,
                description=description,
                author=author,
                tags=tags,
                severity=severity,
                type=file_type,
                path=str(template_file),
                content=template_data
            )
            
            # Store the template
            self.templates[template_id] = template
            return template
            
        except Exception as e:
            logger.error(f"Failed to load template {template_file}: {str(e)}")
            return None
    
    def _detect_template_type(self, template_file: Path) -> ScannerType:
        """
        Detect the template type based on the file path or content.
        
        Args:
            template_file: Path to the template file
            
        Returns:
            Template type
        """
        if "nuclei" in template_file.parts:
            return ScannerType.NUCLEI
        elif "openvas" in template_file.parts:
            return ScannerType.OPENVAS
        else:
            return ScannerType.CUSTOM
    
    async def scan_target(self, target: str, 
                         template_ids: Optional[List[str]] = None,
                         template_tags: Optional[List[str]] = None,
                         scanner_type: ScannerType = ScannerType.NUCLEI,
                         concurrency: Optional[int] = None,
                         timeout: int = 300) -> ScanResult:
        """
        Scan a target using the specified templates.
        
        Args:
            target: Target to scan (URL, IP, hostname)
            template_ids: Specific template IDs to use
            template_tags: Tags to filter templates
            scanner_type: Type of scanner to use
            concurrency: Concurrent requests (overrides global setting)
            timeout: Scan timeout in seconds
            
        Returns:
            Scan result
        """
        if not self.templates:
            await self.load_templates(scanner_type)
            
        # Create scan result
        scan_id = str(uuid.uuid4())
        scan_result = ScanResult(
            id=scan_id,
            target=target,
            scan_type=scanner_type,
            start_time=datetime.now(),
        )
        
        try:
            # Apply rate limiting
            await self._rate_limit_scan()
            
            # Acquire semaphore for concurrency control
            async with self.scan_semaphore:
                logger.info(f"Starting scan {scan_id} for target {target}")
                
                # Filter templates based on IDs and tags
                templates_to_run = await self._filter_templates(template_ids, template_tags, scanner_type)
                
                if not templates_to_run:
                    logger.warning(f"No templates found for scan {scan_id}")
                    scan_result.summary = {"status": "completed", "message": "No templates found"}
                    scan_result.end_time = datetime.now()
                    return scan_result
                
                logger.info(f"Running {len(templates_to_run)} templates against {target}")
                
                # Run the appropriate scanner based on type
                if scanner_type == ScannerType.NUCLEI:
                    vulnerabilities = await self._run_nuclei_scan(target, templates_to_run, scan_id, concurrency, timeout)
                elif scanner_type == ScannerType.OPENVAS:
                    vulnerabilities = await self._run_openvas_scan(target, templates_to_run, scan_id, timeout)
                else:  # CUSTOM scanner
                    vulnerabilities = await self._run_custom_scan(target, templates_to_run, scan_id, concurrency, timeout)
                
                # Add discovered vulnerabilities to the scan result
                scan_result.vulnerabilities = vulnerabilities
                
                # Create summary
                severity_counts = {"info": 0, "low": 0, "medium": 0, "high": 0, "critical": 0}
                for vuln in vulnerabilities:
                    severity_counts[vuln.severity.value] += 1
                
                scan_result.summary = {
                    "status": "completed",
                    "target": target,
                    "template_count": len(templates_to_run),
                    "vulnerability_count": len(vulnerabilities),
                    "severity_counts": severity_counts,
                    "duration_seconds": (datetime.now() - scan_result.start_time).total_seconds()
                }
                
                # Store results in database
                await self._store_scan_result(scan_result)
                
                logger.info(f"Scan {scan_id} completed with {len(vulnerabilities)} vulnerabilities found")
                
        except Exception as e:
            logger.error(f"Error during scan {scan_id}: {str(e)}")
            scan_result.summary = {"status": "error", "message": str(e)}
        finally:
            scan_result.end_time = datetime.now()
            
        return scan_result
    
    async def _filter_templates(self, template_ids: Optional[List[str]] = None,
                              template_tags: Optional[List[str]] = None,
                              scanner_type: Optional[ScannerType] = None) -> List[Template]:
        """
        Filter templates based on IDs, tags, and scanner type.
        
        Args:
            template_ids: Specific template IDs to use
            template_tags: Tags to filter templates
            scanner_type: Type of scanner to use
            
        Returns:
            List of filtered templates
        """
        result = []
        
        for template_id, template in self.templates.items():
            # Filter by template ID if specified
            if template_ids and template_id not in template_ids:
                continue
                
            # Filter by scanner type if specified
            if scanner_type and template.type != scanner_type:
                continue
                
            # Filter by tags if specified
            if template_tags:
                if not any(tag in template.tags for tag in template_tags):
                    continue
                    
            result.append(template)
            
        return result
    
    async def _rate_limit_scan(self):
        """Apply rate limiting to scans."""
        current_time = time.time()
        time_since_last_scan = current_time - self.last_scan_time
        
        if time_since_last_scan < (1.0 / self.scan_rate_limit):
            await asyncio.sleep((1.0 / self.scan_rate_limit) - time_since_last_scan)
            
        self.last_scan_time = time.time()
    
    async def _rate_limit_host_request(self, host: str):
        """Apply rate limiting to requests for a specific host."""
        if host not in self.host_rate_limiters:
            self.host_rate_limiters[host] = asyncio.Semaphore(self.requests_per_host)
            self.host_last_request[host] = 0
            
        async with self.host_rate_limiters[host]:
            current_time = time.time()
            time_since_last_request = current_time - self.host_last_request.get(host, 0)
            
            if time_since_last_request < (1.0 / self.requests_per_host):
                await asyncio.sleep((1.0 / self.requests_per_host) - time_since_last_request)
                
            self.host_last_request[host] = time.time()
    
    async def _run_nuclei_scan(self, target: str, templates: List[Template], 
                             scan_id: str, concurrency: Optional[int] = None,
                             timeout: int = 300) -> List[Vulnerability]:
        """
        Run a Nuclei scan against a target.
        
        Args:
            target: Target to scan
            templates: Templates to use
            scan_id: Scan ID
            concurrency: Concurrent requests
            timeout: Scan timeout in seconds
            
        Returns:
            List of discovered vulnerabilities
        """
        logger.info(f"Running Nuclei scan against {target} with {len(templates)} templates")
        vulnerabilities = []
        
        # Create temporary directory for results
        with tempfile.TemporaryDirectory() as temp_dir:
            output_file = os.path.join(temp_dir, f"nuclei-{scan_id}.json")
            
            # Create template file with references to templates
            template_file = os.path.join(temp_dir, f"templates-{scan_id}.txt")
            async with aiofiles.open(template_file, 'w') as f:
                for template in templates:
                    if template.path:
                        await f.write(f"{template.path}\n")
            
            # Build Nuclei command
            cmd = [
                self.nuclei_path,
                "-target", target,
                "-t", template_file,
                "-json", "-o", output_file,
                "-bulks", str(concurrency or self.max_concurrent_scans),
                "-timeout", str(timeout),
            ]
            
            # Execute Nuclei
            try:
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)
                
                # Check for execution errors
                if process.returncode != 0:
                    error = stderr.decode().strip() if stderr else "Unknown error"
                    logger.error(f"Nuclei execution failed: {error}")
                    return vulnerabilities
                
                # Parse results if output file exists
                if os.path.exists(output_file):
                    async with aiofiles.open(output_file, 'r') as f:
                        content = await f.read()
                        
                    # Nuclei can output multiple JSON objects, one per line
                    for line in content.splitlines():
                        if not line.strip():
                            continue
                            
                        try:
                            finding = json.loads(line)
                            vuln = self._parse_nuclei_finding(finding, target, scan_id)
                            if vuln:
                                vulnerabilities.append(vuln)
                        except json.JSONDecodeError as e:
                            logger.error(f"Failed to parse Nuclei result: {str(e)}")
                
            except asyncio.TimeoutError:
                logger.error(f"Nuclei scan timed out after {timeout} seconds")
            except Exception as e:
                logger.error(f"Error during Nuclei scan: {str(e)}")
                
        return vulnerabilities
    
    def _parse_nuclei_finding(self, finding: Dict[str, Any], target: str, scan_id: str) -> Optional[Vulnerability]:
        """
        Parse a Nuclei finding and convert to a vulnerability.
        
        Args:
            finding: Nuclei finding JSON
            target: Target that was scanned
            scan_id: Scan ID
            
        Returns:
            Vulnerability object or None
        """
        try:
            # Extract required fields
            name = finding.get("info", {}).get("name", "Unknown Vulnerability")
            template_id = finding.get("template-id", "unknown")
            severity_str = finding.get("info", {}).get("severity", "medium").lower()
            
            # Convert severity string to enum
            try:
                severity = Severity[severity_str.upper()]
            except KeyError:
                severity = Severity.MEDIUM
                
            # Extract description and references
            description = finding.get("info", {}).get("description", f"Vulnerability discovered: {name}")
            references = finding.get("info", {}).get("reference", [])
            if isinstance(references, str):
                references = [references]
                
            # Extract remediation
            remediation = finding.get("info", {}).get("remediation", None)
            
            # Create a unique ID for the vulnerability
            vuln_id = str(uuid.uuid4())
            
            # Calculate CVSS score if available
            cvss_vector = finding.get("info", {}).get("classification", {}).get("cvss-metrics", None)
            cvss_score = None
            if cvss_vector:
                try:
                    cvss_obj = cvss.CVSS3(cvss_vector)
                    cvss_score = cvss_obj.base_score
                except Exception as e:
                    logger.error(f"Failed to parse CVSS vector: {str(e)}")
            
            # Create the vulnerability object
            return Vulnerability(
                id=vuln_id,
                name=name,
                description=description,
                target=target,
                template_id=template_id,
                severity=severity,
                cvss_score=cvss_score,
                cvss_vector=cvss_vector,
                references=references,
                details=finding,
                remediation=remediation,
                detected_at=datetime.now()
            )
        except Exception as e:
            logger.error(f"Error parsing Nuclei finding: {str(e)}")
            return None
    
    async def _run_openvas_scan(self, target: str, templates: List[Template], 
                              scan_id: str, timeout: int = 1800) -> List[Vulnerability]:
        """
        Run an OpenVAS scan against a target with robust error handling.
        
        Args:
            target: Target to scan
            templates: Templates to use
            scan_id: Scan ID
            timeout: Scan timeout in seconds
            
        Returns:
            List of discovered vulnerabilities
        """
        logger.info(f"Running OpenVAS scan against {target}")
        vulnerabilities = []
        
        # Track resources for cleanup
        resources = {
            "target_id": None,
            "task_id": None,
            "report_id": None
        }
        
        try:
            # Validate OpenVAS configuration
            if not self.openvas_host or not self.openvas_port:
                raise ValueError("OpenVAS host and port must be configured")
                
            # Build the OpenVAS configuration
            config = {
                "target": {
                    "hosts": [target],
                    "ports": "T:1-65535,U:53,123,161,500"
                },
                "scan": {
                    "profile": "Full and fast"
                }
            }
            
            # Configure connection with proper error handling
            connector = aiohttp.TCPConnector(ssl=False)
            auth = aiohttp.BasicAuth(self.openvas_username, self.openvas_password)
            timeout_config = aiohttp.ClientTimeout(total=60)  # 60 seconds timeout for API calls
            
            async with aiohttp.ClientSession(
                connector=connector, 
                auth=auth, 
                timeout=timeout_config,
                raise_for_status=False  # We'll handle status codes manually
            ) as session:
                # Check OpenVAS connectivity first
                try:
                    status_check_url = f"https://{self.openvas_host}:{self.openvas_port}/osp/get_version"
                    async with session.get(status_check_url) as resp:
                        if resp.status != 200:
                            error_text = await resp.text()
                            logger.error(f"OpenVAS service unavailable: {resp.status} - {error_text}")
                            return vulnerabilities
                        version_info = await resp.json()
                        logger.info(f"Connected to OpenVAS version: {version_info.get('version', 'unknown')}")
                except aiohttp.ClientError as e:
                    logger.error(f"Failed to connect to OpenVAS service: {str(e)}")
                    return vulnerabilities
                
                # Create target with error handling
                try:
                    target_url = f"https://{self.openvas_host}:{self.openvas_port}/osp/create_target"
                    target_data = {
                        "name": f"Scan {scan_id}", 
                        "hosts": target, 
                        "port_list": "All TCP and important UDP"
                    }
                    
                    async with session.post(target_url, json=target_data) as resp:
                        if resp.status != 200:
                            error_text = await resp.text()
                            logger.error(f"Failed to create OpenVAS target: {resp.status} - {error_text}")
                            return vulnerabilities
                            
                        target_resp = await resp.json()
                        if "id" not in target_resp:
                            logger.error(f"Invalid response from OpenVAS create_target: {target_resp}")
                            return vulnerabilities
                            
                        target_id = target_resp["id"]
                        resources["target_id"] = target_id
                        logger.info(f"Created OpenVAS target with ID: {target_id}")
                except aiohttp.ClientError as e:
                    logger.error(f"Network error creating OpenVAS target: {str(e)}")
                    return vulnerabilities
                    
                # Create task with error handling
                try:
                    task_url = f"https://{self.openvas_host}:{self.openvas_port}/osp/create_task"
                    task_data = {
                        "name": f"Scan {scan_id}", 
                        "target_id": target_id, 
                        "config_id": "daba56c8-73ec-11df-a475-002264764cea"  # Full and fast profile
                    }
                    
                    async with session.post(task_url, json=task_data) as resp:
                        if resp.status != 200:
                            error_text = await resp.text()
                            logger.error(f"Failed to create OpenVAS task: {resp.status} - {error_text}")
                            return vulnerabilities
                            
                        task_resp = await resp.json()
                        if "id" not in task_resp:
                            logger.error(f"Invalid response from OpenVAS create_task: {task_resp}")
                            return vulnerabilities
                            
                        task_id = task_resp["id"]
                        resources["task_id"] = task_id
                        logger.info(f"Created OpenVAS task with ID: {task_id}")
                except aiohttp.ClientError as e:
                    logger.error(f"Network error creating OpenVAS task: {str(e)}")
                    return vulnerabilities
                    
                # Start scan with error handling
                try:
                    start_url = f"https://{self.openvas_host}:{self.openvas_port}/osp/start_task"
                    start_data = {"task_id": task_id}
                    
                    async with session.post(start_url, json=start_data) as resp:
                        if resp.status != 200:
                            error_text = await resp.text()
                            logger.error(f"Failed to start OpenVAS scan: {resp.status} - {error_text}")
                            return vulnerabilities
                            
                        start_resp = await resp.json()
                        if "report_id" not in start_resp:
                            logger.error(f"Invalid response from OpenVAS start_task: {start_resp}")
                            return vulnerabilities
                            
                        report_id = start_resp["report_id"]
                        resources["report_id"] = report_id
                        logger.info(f"Started OpenVAS scan with report ID: {report_id}")
                except aiohttp.ClientError as e:
                    logger.error(f"Network error starting OpenVAS scan: {str(e)}")
                    return vulnerabilities
                    
                # Wait for scan to complete with improved status tracking
                status_url = f"https://{self.openvas_host}:{self.openvas_port}/osp/get_task"
                status_data = {"task_id": task_id}
                
                start_time = time.time()
                last_progress = -1
                retry_count = 0
                max_retries = 5
                
                while time.time() - start_time < timeout:
                    try:
                        await asyncio.sleep(10)  # Check every 10 seconds
                        
                        async with session.post(status_url, json=status_data) as resp:
                            if resp.status != 200:
                                retry_count += 1
                                error_text = await resp.text()
                                logger.warning(f"Failed to get OpenVAS task status (attempt {retry_count}/{max_retries}): {resp.status} - {error_text}")
                                
                                if retry_count >= max_retries:
                                    logger.error("Maximum retries reached for status check")
                                    break
                                    
                                continue
                                
                            status_resp = await resp.json()
                            status = status_resp.get("status")
                            progress = status_resp.get("progress", -1)
                            
                            # Log progress updates
                            if progress != last_progress:
                                logger.info(f"OpenVAS scan progress: {progress}% - Status: {status}")
                                last_progress = progress
                                
                            if status == "Done":
                                logger.info("OpenVAS scan completed successfully")
                                break
                            elif status in ["Stopped", "Failed"]:
                                logger.error(f"OpenVAS scan {status}: {status_resp.get('status_text', 'No details')}")
                                return vulnerabilities
                                
                            # Reset retry counter on successful status check
                            retry_count = 0
                            
                    except aiohttp.ClientError as e:
                        retry_count += 1
                        logger.warning(f"Network error checking OpenVAS status (attempt {retry_count}/{max_retries}): {str(e)}")
                        
                        if retry_count >= max_retries:
                            logger.error("Maximum retries reached for status check")
                            break
                else:
                    logger.error(f"OpenVAS scan timed out after {timeout} seconds")
                    # Try to stop the task if it timed out
                    try:
                        stop_url = f"https://{self.openvas_host}:{self.openvas_port}/osp/stop_task"
                        stop_data = {"task_id": task_id}
                        async with session.post(stop_url, json=stop_data) as resp:
                            if resp.status == 200:
                                logger.info(f"Successfully stopped timed out task {task_id}")
                            else:
                                logger.warning(f"Failed to stop timed out task: {resp.status}")
                    except Exception as e:
                        logger.warning(f"Error stopping timed out task: {str(e)}")
                    return vulnerabilities
                    
                # Get results with error handling
                try:
                    results_url = f"https://{self.openvas_host}:{self.openvas_port}/osp/get_report"
                    results_data = {
                        "report_id": report_id, 
                        "format_id": "a994b278-1f62-11e1-96ac-406186ea4fc5"  # XML format
                    }
                    
                    async with session.post(results_url, json=results_data) as resp:
                        if resp.status != 200:
                            error_text = await resp.text()
                            logger.error(f"Failed to get OpenVAS report: {resp.status} - {error_text}")
                            return vulnerabilities
                            
                        report_content = await resp.read()
                        if not report_content:
                            logger.error("Empty report received from OpenVAS")
                            return vulnerabilities
                            
                        logger.info(f"Retrieved OpenVAS report, size: {len(report_content)} bytes")
                        
                        # Parse the XML report and convert to vulnerabilities
                        vulnerabilities = self._parse_openvas_report(report_content, target, scan_id)
                        logger.info(f"Parsed {len(vulnerabilities)} vulnerabilities from OpenVAS report")
                except aiohttp.ClientError as e:
                    logger.error(f"Network error retrieving OpenVAS report: {str(e)}")
                    return vulnerabilities
                
        except Exception as e:
            logger.error(f"Error during OpenVAS scan: {str(e)}")
        finally:
            # Clean up resources if possible
            if any(resources.values()):
                logger.info("Cleaning up OpenVAS resources...")
                try:
                    async with aiohttp.ClientSession(connector=connector, auth=auth) as cleanup_session:
                        # Delete task if it exists
                        if resources["task_id"]:
                            delete_task_url = f"https://{self.openvas_host}:{self.openvas_port}/osp/delete_task"
                            delete_task_data = {"task_id": resources["task_id"]}
                            try:
                                async with cleanup_session.post(delete_task_url, json=delete_task_data) as resp:
                                    if resp.status == 200:
                                        logger.info(f"Successfully deleted task {resources['task_id']}")
                                    else:
                                        logger.warning(f"Failed to delete task: {resp.status}")
                            except Exception as e:
                                logger.warning(f"Error deleting task: {str(e)}")
                                
                        # Delete target if it exists
                        if resources["target_id"]:
                            delete_target_url = f"https://{self.openvas_host}:{self.openvas_port}/osp/delete_target"
                            delete_target_data = {"target_id": resources["target_id"]}
                            try:
                                async with cleanup_session.post(delete_target_url, json=delete_target_data) as resp:
                                    if resp.status == 200:
                                        logger.info(f"Successfully deleted target {resources['target_id']}")
                                    else:
                                        logger.warning(f"Failed to delete target: {resp.status}")
                            except Exception as e:
                                logger.warning(f"Error deleting target: {str(e)}")
                except Exception as e:
                    logger.warning(f"Error during resource cleanup: {str(e)}")
            
        return vulnerabilities
    
    def _parse_openvas_report(self, report_content: bytes, target: str, scan_id: str) -> List[Vulnerability]:
        """
        Parse an OpenVAS XML report and convert to vulnerabilities.
        
        Args:
            report_content: OpenVAS report XML content
            target: Target that was scanned
            scan_id: Scan ID
            
        Returns:
            List of vulnerabilities
        """
        import xml.etree.ElementTree as ET
        
        vulnerabilities = []
        
        try:
            # Parse XML
            root = ET.fromstring(report_content)
            
            # Extract findings (each result is a potential vulnerability)
            for result in root.findall(".//result"):
                try:
                    # Extract vulnerability information
                    name = result.find("name").text if result.find("name") is not None else "Unknown"
                    description = result.find("description").text if result.find("description") is not None else ""
                    
                    # Extract severity
                    severity_text = result.find("severity").text if result.find("severity") is not None else "medium"
                    try:
                        severity_value = float(severity_text)
                        if severity_value >= 9.0:
                            severity = Severity.CRITICAL
                        elif severity_value >= 7.0:
                            severity = Severity.HIGH
                        elif severity_value >= 4.0:
                            severity = Severity.MEDIUM
                        elif severity_value > 0:
                            severity = Severity.LOW
                        else:
                            severity = Severity.INFO
                    except (ValueError, TypeError):
                        severity = Severity.MEDIUM
                        
                    # Extract other details
                    vuln_id = str(uuid.uuid4())
                    template_id = result.find("nvt/oid").text if result.find("nvt/oid") is not None else "unknown"
                    cvss_base = result.find("nvt/cvss_base").text if result.find("nvt/cvss_base") is not None else None
                    
                    # Extract references
                    references = []
                    for ref in result.findall("nvt/refs/ref"):
                        ref_id = ref.get("id")
                        ref_type = ref.get("type")
                        references.append(f"{ref_type}:{ref_id}")
                        
                    # Extract remediation
                    solution = result.find("nvt/solution").text if result.find("nvt/solution") is not None else None
                    
                    # Convert to vulnerability object
                    vuln = Vulnerability(
                        id=vuln_id,
                        name=name,
                        description=description,
                        target=target,
                        template_id=template_id,
                        severity=severity,
                        cvss_score=float(cvss_base) if cvss_base else None,
                        cvss_vector=None,  # OpenVAS doesn't always provide the vector
                        references=references,
                        remediation=solution,
                        details={"xml_data": ET.tostring(result).decode("utf-8")},
                        detected_at=datetime.now()
                    )
                    
                    vulnerabilities.append(vuln)
                    
                except Exception as e:
                    logger.error(f"Error parsing OpenVAS result: {str(e)}")
                    
        except Exception as e:
            logger.error(f"Error parsing OpenVAS report: {str(e)}")
            
        return vulnerabilities
    
    async def _run_custom_scan(self, target: str, templates: List[Template], 
                             scan_id: str, concurrency: Optional[int] = None,
                             timeout: int = 300) -> List[Vulnerability]:
        """
        Run a custom scan against a target.
        
        Args:
            target: Target to scan
            templates: Templates to use
            scan_id: Scan ID
            concurrency: Concurrent requests
            timeout: Scan timeout in seconds
            
        Returns:
            List of discovered vulnerabilities
        """
        logger.info(f"Running custom scan against {target} with {len(templates)} templates")
        
        # Set up concurrency control
        actual_concurrency = concurrency or self.max_concurrent_scans
        semaphore = asyncio.Semaphore(actual_concurrency)
        
        # Process all templates concurrently with rate limiting
        tasks = []
        for template in templates:
            task = asyncio.create_task(self._process_custom_template(
                target, template, scan_id, semaphore, timeout
            ))
            tasks.append(task)
            
        # Wait for all template processing tasks to complete
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Process results
        vulnerabilities = []
        for result in results:
            if isinstance(result, list):
                vulnerabilities.extend(result)
            elif isinstance(result, Exception):
                logger.error(f"Error processing template: {str(result)}")
                
        return vulnerabilities
        
    async def _process_custom_template(self, target: str, template: Template, 
                                     scan_id: str, semaphore: asyncio.Semaphore,
                                     timeout: int) -> List[Vulnerability]:
        """
        Process a single custom template against a target.
        
        Args:
            target: Target to scan
            template: Template to process
            scan_id: Scan ID
            semaphore: Semaphore for concurrency control
            timeout: Processing timeout in seconds
            
        Returns:
            List of discovered vulnerabilities
        """
        async with semaphore:
            # Apply host-based rate limiting
            await self._rate_limit_host_request(target)
            
            vulnerabilities = []
            
            try:
                if not template.content:
                    logger.warning(f"Template {template.id} has no content")
                    return vulnerabilities
                    
                # Extract checks from the template
                checks = template.content.get("checks", [])
                if not checks:
                    logger.warning(f"Template {template.id} has no checks")
                    return vulnerabilities
                    
                # Process each check in the template
                for check in checks:
                    check_type = check.get("type", "http")
                    
                    if check_type == "http":
                        vulns = await self._process_http_check(target, template, check, scan_id, timeout)
                        vulnerabilities.extend(vulns)
                    elif check_type == "tcp":
                        vulns = await self._process_tcp_check(target, template, check, scan_id, timeout)
                        vulnerabilities.extend(vulns)
                    elif check_type == "dns":
                        vulns = await self._process_dns_check(target, template, check, scan_id, timeout)
                        vulnerabilities.extend(vulns)
                    else:
                        logger.warning(f"Unsupported check type: {check_type}")
                        
            except Exception as e:
                logger.error(f"Error processing template {template.id}: {str(e)}")
                
            return vulnerabilities
                
    async def _process_http_check(self, target: str, template: Template, 
                               check: Dict[str, Any], scan_id: str,
                               timeout: int) -> List[Vulnerability]:
        """
        Process an HTTP check against a target.
        
        Args:
            target: Target to scan
            template: Template containing the check
            check: Check definition
            scan_id: Scan ID
            timeout: Check timeout in seconds
            
        Returns:
            List of discovered vulnerabilities
        """
        vulnerabilities = []
        
        try:
            # Prepare target URL
            target_url = target
            if not target_url.startswith(('http://', 'https://')):
                target_url = f"http://{target_url}"
                
            # Extract path and method
            path = check.get("path", "/")
            method = check.get("method", "GET").upper()
            
            # Combine URL and path
            if not target_url.endswith('/') and not path.startswith('/'):
                url = f"{target_url}/{path}"
            else:
                url = f"{target_url}{path}"
                
            # Extract headers and body
            headers = check.get("headers", {})
            body = check.get("body")
            
            # Extract matching conditions
            matchers = check.get("matchers", [])
            
            # Perform the HTTP request
            async with aiohttp.ClientSession() as session:
                request_kwargs = {
                    "method": method,
                    "url": url,
                    "headers": headers,
                    "timeout": aiohttp.ClientTimeout(total=timeout),
                    "ssl": False,  # Skip SSL verification for security testing
                }
                
                if body:
                    request_kwargs["data"] = body
                    
                try:
                    async with session.request(**request_kwargs) as response:
                        # Read response
                        response_text = await response.text()
                        response_headers = dict(response.headers)
                        status_code = response.status
                        
                        # Check if the response matches any matchers
                        for matcher in matchers:
                            match_type = matcher.get("type", "regex")
                            match_part = matcher.get("part", "body")
                            match_value = matcher.get("value", "")
                            
                            # Determine what to match against
                            if match_part == "body":
                                content_to_match = response_text
                            elif match_part == "header":
                                header_name = matcher.get("header", "").lower()
                                content_to_match = response_headers.get(header_name, "")
                            elif match_part == "status":
                                content_to_match = str(status_code)
                            else:
                                continue
                                
                            # Perform the match
                            match_found = False
                            if match_type == "regex":
                                try:
                                    if re.search(match_value, content_to_match, re.IGNORECASE):
                                        match_found = True
                                except re.error:
                                    logger.error(f"Invalid regex pattern: {match_value}")
                            elif match_type == "word":
                                if match_value in content_to_match:
                                    match_found = True
                            elif match_type == "binary":
                                try:
                                    binary_pattern = bytes.fromhex(match_value.replace(" ", ""))
                                    if binary_pattern in content_to_match.encode():
                                        match_found = True
                                except ValueError:
                                    logger.error(f"Invalid binary pattern: {match_value}")
                                    
                            # If a match is found, create a vulnerability
                            if match_found:
                                vuln_id = str(uuid.uuid4())
                                name = template.name
                                description = template.description
                                
                                # Create vulnerability
                                vuln = Vulnerability(
                                    id=vuln_id,
                                    name=name,
                                    description=description,
                                    target=target,
                                    template_id=template.id,
                                    severity=template.severity,
                                    details={
                                        "url": url,
                                        "method": method,
                                        "status_code": status_code,
                                        "response_snippet": response_text[:500] if len(response_text) > 500 else response_text,
                                        "matcher": matcher
                                    },
                                    detected_at=datetime.now()
                                )
                                
                                vulnerabilities.append(vuln)
                                break  # One vulnerability per check is enough
                        
                except aiohttp.ClientError as e:
                    logger.error(f"HTTP request error for {url}: {str(e)}")
                    
        except Exception as e:
            logger.error(f"Error processing HTTP check: {str(e)}")
            
        return vulnerabilities
        
    async def _process_tcp_check(self, target: str, template: Template, 
                              check: Dict[str, Any], scan_id: str,
                              timeout: int) -> List[Vulnerability]:
        """
        Process a TCP check against a target.
        
        Args:
            target: Target to scan
            template: Template containing the check
            check: Check definition
            scan_id: Scan ID
            timeout: Check timeout in seconds
            
        Returns:
            List of discovered vulnerabilities
        """
        vulnerabilities = []
        
        try:
            # Extract target details
            host = target
            port = check.get("port", 80)
            if ":" in target:
                host, port_str = target.split(":", 1)
                try:
                    port = int(port_str)
                except ValueError:
                    pass
                    
            # Extract data to send and match patterns
            data = check.get("data", "").encode()
            matchers = check.get("matchers", [])
            
            # Connect to the target
            try:
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(host, port),
                    timeout=timeout
                )
                
                # Send data if specified
                if data:
                    writer.write(data)
                    await writer.drain()
                    
                # Read response
                response = await asyncio.wait_for(reader.read(4096), timeout=timeout)
                
                # Check if the response matches any matchers
                for matcher in matchers:
                    match_type = matcher.get("type", "binary")
                    match_value = matcher.get("value", "")
                    
                    # Perform the match
                    match_found = False
                    if match_type == "binary":
                        try:
                            binary_pattern = bytes.fromhex(match_value.replace(" ", ""))
                            if binary_pattern in response:
                                match_found = True
                        except ValueError:
                            logger.error(f"Invalid binary pattern: {match_value}")
                    elif match_type == "regex":
                        try:
                            if re.search(match_value, response.decode("latin1"), re.IGNORECASE):
                                match_found = True
                        except re.error:
                            logger.error(f"Invalid regex pattern: {match_value}")
                    elif match_type == "word":
                        if match_value.encode() in response:
                            match_found = True
                            
                    # If a match is found, create a vulnerability
                    if match_found:
                        vuln_id = str(uuid.uuid4())
                        name = template.name
                        description = template.description
                        
                        # Create vulnerability
                        vuln = Vulnerability(
                            id=vuln_id,
                            name=name,
                            description=description,
                            target=f"{host}:{port}",
                            template_id=template.id,
                            severity=template.severity,
                            details={
                                "host": host,
                                "port": port,
                                "response_hex": response.hex()[:100] if response else "",
                                "matcher": matcher
                            },
                            detected_at=datetime.now()
                        )
                        
                        vulnerabilities.append(vuln)
                        break  # One vulnerability per check is enough
                    
                # Close the connection
                writer.close()
                await writer.wait_closed()
                
            except (asyncio.TimeoutError, ConnectionRefusedError, OSError) as e:
                logger.error(f"TCP connection error for {host}:{port}: {str(e)}")
                
        except Exception as e:
            logger.error(f"Error processing TCP check: {str(e)}")
            
        return vulnerabilities
        
    async def _process_dns_check(self, target: str, template: Template, 
                              check: Dict[str, Any], scan_id: str,
                              timeout: int) -> List[Vulnerability]:
        """
        Process a DNS check against a target.
        
        Args:
            target: Target to scan
            template: Template containing the check
            check: Check definition
            scan_id: Scan ID
            timeout: Check timeout in seconds
            
        Returns:
            List of discovered vulnerabilities
        """
        import aiodns
        
        vulnerabilities = []
        
        try:
            # Create DNS resolver
            resolver = aiodns.DNSResolver()
            
            # Extract check details
            record_type = check.get("type", "A").upper()
            domain = target
            matchers = check.get("matchers", [])
            
            # Perform DNS lookup
            try:
                if record_type == "A":
                    result = await asyncio.wait_for(resolver.query(domain, "A"), timeout=timeout)
                    records = [r.host for r in result]
                elif record_type == "AAAA":
                    result = await asyncio.wait_for(resolver.query(domain, "AAAA"), timeout=timeout)
                    records = [r.host for r in result]
                elif record_type == "CNAME":
                    result = await asyncio.wait_for(resolver.query(domain, "CNAME"), timeout=timeout)
                    records = [r.cname for r in result]
                elif record_type == "MX":
                    result = await asyncio.wait_for(resolver.query(domain, "MX"), timeout=timeout)
                    records = [f"{r.priority} {r.host}" for r in result]
                elif record_type == "TXT":
                    result = await asyncio.wait_for(resolver.query(domain, "TXT"), timeout=timeout)
                    records = [r.text for r in result]
                elif record_type == "NS":
                    result = await asyncio.wait_for(resolver.query(domain, "NS"), timeout=timeout)
                    records = [r.host for r in result]
                elif record_type == "SOA":
                    result = await asyncio.wait_for(resolver.query(domain, "SOA"), timeout=timeout)
                    records = [f"{r.mname} {r.rname} {r.serial} {r.refresh} {r.retry} {r.expire} {r.minimum}"]
                else:
                    logger.warning(f"Unsupported DNS record type: {record_type}")
                    return vulnerabilities
                    
                # Convert records to string for matching
                records_str = "\n".join(records)
                
                # Check if the records match any matchers
                for matcher in matchers:
                    match_type = matcher.get("type", "regex")
                    match_value = matcher.get("value", "")
                    
                    # Perform the match
                    match_found = False
                    if match_type == "regex":
                        try:
                            if re.search(match_value, records_str, re.IGNORECASE):
                                match_found = True
                        except re.error:
                            logger.error(f"Invalid regex pattern: {match_value}")
                    elif match_type == "word":
                        if match_value in records_str:
                            match_found = True
                            
                    # If a match is found, create a vulnerability
                    if match_found:
                        vuln_id = str(uuid.uuid4())
                        name = template.name
                        description = template.description
                        
                        # Create vulnerability
                        vuln = Vulnerability(
                            id=vuln_id,
                            name=name,
                            description=description,
                            target=domain,
                            template_id=template.id,
                            severity=template.severity,
                            details={
                                "domain": domain,
                                "record_type": record_type,
                                "records": records,
                                "matcher": matcher
                            },
                            detected_at=datetime.now()
                        )
                        
                        vulnerabilities.append(vuln)
                        break  # One vulnerability per check is enough
                    
            except aiodns.error.DNSError as e:
                logger.error(f"DNS lookup error for {domain} ({record_type}): {str(e)}")
                
        except Exception as e:
            logger.error(f"Error processing DNS check: {str(e)}")
            
        return vulnerabilities
    
    async def _store_scan_result(self, scan_result: ScanResult) -> bool:
        """
        Store a scan result in the database.
        
        Args:
            scan_result: Scan result to store
            
        Returns:
            True if successful, False otherwise
        """
        if not self.db_connection_string:
            logger.warning("Database connection string not provided, skipping result storage")
            return False
            
        try:
            # Connect to database
            conn = psycopg2.connect(self.db_connection_string)
            cursor = conn.cursor()
            
            # Create tables if they don't exist
            self._ensure_tables_exist(cursor)
            
            # Store scan result
            cursor.execute(
                """
                INSERT INTO vulnerability_scans 
                (id, target, scan_type, start_time, end_time, summary)
                VALUES (%s, %s, %s, %s, %s, %s)
                """,
                (
                    scan_result.id,
                    scan_result.target,
                    scan_result.scan_type.value,
                    scan_result.start_time,
                    scan_result.end_time,
                    Json(scan_result.summary)
                )
            )
            
            # Store vulnerabilities
            if scan_result.vulnerabilities:
                vulnerability_data = []
                for vuln in scan_result.vulnerabilities:
                    vulnerability_data.append((
                        vuln.id,
                        scan_result.id,
                        vuln.name,
                        vuln.description,
                        vuln.target,
                        vuln.template_id,
                        vuln.severity.value,
                        vuln.cvss_score,
                        vuln.cvss_vector,
                        Json(vuln.references),
                        Json(vuln.details),
                        vuln.remediation,
                        vuln.detected_at
                    ))
                
                execute_values(
                    cursor,
                    """
                    INSERT INTO vulnerabilities
                    (id, scan_id, name, description, target, template_id, severity, 
                     cvss_score, cvss_vector, references, details, remediation, detected_at)
                    VALUES %s
                    """,
                    vulnerability_data
                )
                
            # Commit transaction
            conn.commit()
            cursor.close()
            conn.close()
            
            logger.info(f"Stored scan result {scan_result.id} in database")
            return True
            
        except Exception as e:
            logger.error(f"Error storing scan result in database: {str(e)}")
            return False
    
    def _ensure_tables_exist(self, cursor) -> None:
        """
        Ensure that the necessary database tables exist.
        
        Args:
            cursor: Database cursor
        """
        # Create vulnerability_scans table
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS vulnerability_scans (
                id TEXT PRIMARY KEY,
                target TEXT NOT NULL,
                scan_type TEXT NOT NULL,
                start_time TIMESTAMP NOT NULL,
                end_time TIMESTAMP,
                summary JSONB,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
            """
        )
        
        # Create vulnerabilities table
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                id TEXT PRIMARY KEY,
                scan_id TEXT NOT NULL REFERENCES vulnerability_scans(id) ON DELETE CASCADE,
                name TEXT NOT NULL,
                description TEXT,
                target TEXT NOT NULL,
                template_id TEXT,
                severity TEXT NOT NULL,
                cvss_score REAL,
                cvss_vector TEXT,
                references JSONB,
                details JSONB,
                remediation TEXT,
                detected_at TIMESTAMP NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
            """
        )
        
        # Create indexes for fast querying
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_vuln_scan_id ON vulnerabilities(scan_id)")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_vuln_severity ON vulnerabilities(severity)")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_vuln_target ON vulnerabilities(target)")


async def scan_target(target: str, template_ids: Optional[List[str]] = None,
                     template_tags: Optional[List[str]] = None,
                     scanner_type: str = "nuclei",
                     concurrency: Optional[int] = None,
                     timeout: int = 300,
                     config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Scan a target for vulnerabilities using the Vulnerability Scanner.
    
    Args:
        target: Target to scan (URL, IP, hostname)
        template_ids: Specific template IDs to use
        template_tags: Tags to filter templates
        scanner_type: Type of scanner to use
        concurrency: Concurrent requests
        timeout: Scan timeout in seconds
        config: Scanner configuration
        
    Returns:
        Dictionary containing scan results
    """
    try:
        # Create scanner
        scanner = VulnerabilityScanner(config)
        
        # Load templates
        await scanner.load_templates()
        
        # Convert scanner type string to enum
        try:
            scanner_type_enum = ScannerType[scanner_type.upper()]
        except KeyError:
            scanner_type_enum = ScannerType.NUCLEI
            
        # Run scan
        scan_result = await scanner.scan_target(
            target=target,
            template_ids=template_ids,
            template_tags=template_tags,
            scanner_type=scanner_type_enum,
            concurrency=concurrency,
            timeout=timeout
        )
        
        # Return results as dictionary
        return scan_result.to_dict()
        
    except Exception as e:
        logger.error(f"Error scanning target: {str(e)}")
        return {
            "status": "error",
            "message": str(e)
        }

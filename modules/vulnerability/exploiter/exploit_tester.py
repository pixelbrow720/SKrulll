"""
Exploit Tester for the SKrulll Orchestrator.

This module provides functionality for testing exploits against vulnerable systems,
with Metasploit RPC integration, containerized execution, and comprehensive reporting.
"""

import base64
import datetime
import json
import logging
import os
import re
import subprocess
import tempfile
import time
import uuid
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import jinja2
import msgpack
import psycopg2
import requests
from psycopg2.extras import Json, execute_values

logger = logging.getLogger(__name__)

# Exploit Types
class ExploitType(Enum):
    METASPLOIT = "metasploit"
    CUSTOM = "custom"
    POC = "poc"


# Exploit Statuses
class ExploitStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    ERROR = "error"


@dataclass
class Exploit:
    """Exploit definition."""
    id: str
    name: str
    description: str
    type: ExploitType
    module_path: Optional[str] = None
    options: Dict[str, Any] = field(default_factory=dict)
    references: List[str] = field(default_factory=list)
    author: Optional[str] = None
    code: Optional[str] = None
    target_requirements: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert exploit to dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "type": self.type.value,
            "module_path": self.module_path,
            "options": self.options,
            "references": self.references,
            "author": self.author,
            "target_requirements": self.target_requirements,
        }


@dataclass
class ExploitResult:
    """Exploit test result."""
    id: str
    exploit_id: str
    target: str
    status: ExploitStatus
    start_time: datetime.datetime
    end_time: Optional[datetime.datetime] = None
    output: Optional[str] = None
    session_id: Optional[str] = None
    details: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert exploit result to dictionary."""
        return {
            "id": self.id,
            "exploit_id": self.exploit_id,
            "target": self.target,
            "status": self.status.value,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "output": self.output,
            "session_id": self.session_id,
            "details": self.details,
        }


class ExploitTester:
    """Exploit tester with Metasploit integration and containerized execution."""
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the Exploit Tester.
        
        Args:
            config: Configuration dictionary
        """
        self.config = config or {}
        
        # Metasploit RPC configuration
        self.msfrpc_host = self.config.get("msfrpc_host", "localhost")
        self.msfrpc_port = self.config.get("msfrpc_port", 55553)
        
        # Use environment variables for sensitive credentials with config fallback
        self._load_msfrpc_credentials()
        
        # Container configuration
        self.use_containers = self.config.get("use_containers", True)
        self.container_image = self.config.get("container_image", "metasploitframework/metasploit-framework")
        
        # Exploit storage
        self.exploits_directory = Path(self.config.get("exploits_directory", "modules/vulnerability/exploiter/exploits"))
        
        # Report configuration
        self.report_template_directory = Path(self.config.get("report_template_directory", "modules/vulnerability/exploiter/templates"))
        
        # Database connection
        self.db_connection_string = self.config.get("db_connection_string", os.environ.get("DATABASE_URL"))
        
        # Cache of loaded exploits
        self.exploits: Dict[str, Exploit] = {}
        
        # MSF RPC API token
        self.msf_api_token = None
        
    def _load_msfrpc_credentials(self) -> None:
        """
        Load MSFRPC credentials with improved security.
        
        Prioritizes credentials from:
        1. Environment variables (most secure)
        2. Secure credential store (if available)
        3. Configuration file (least secure)
        
        Also implements credential rotation and validation.
        """
        # Try to load from environment variables first (most secure)
        username_env = os.environ.get("MSFRPC_USERNAME")
        password_env = os.environ.get("MSFRPC_PASSWORD")
        
        # Try to load from secure credential store if available
        username_secure = None
        password_secure = None
        try:
            # This is a placeholder for integration with a secure credential store
            # such as HashiCorp Vault, AWS Secrets Manager, or similar
            if self.config.get("use_secure_credentials", False):
                credential_store = self.config.get("credential_store", {})
                if credential_store:
                    # Example implementation - would be replaced with actual API calls
                    username_secure = credential_store.get("msfrpc_username")
                    password_secure = credential_store.get("msfrpc_password")
                    logger.info("Loaded MSFRPC credentials from secure credential store")
        except Exception as e:
            logger.warning(f"Failed to load credentials from secure store: {str(e)}")
        
        # Fall back to configuration (least secure)
        username_config = self.config.get("msfrpc_username", "msf")
        password_config = self.config.get("msfrpc_password", "msf")
        
        # Set credentials with priority order
        self.msfrpc_username = username_env or username_secure or username_config
        self.msfrpc_password = password_env or password_secure or password_config
        
        # Log credential source (without revealing the actual credentials)
        if username_env:
            logger.info("Using MSFRPC credentials from environment variables")
        elif username_secure:
            logger.info("Using MSFRPC credentials from secure credential store")
        else:
            logger.warning("Using MSFRPC credentials from configuration file - consider using environment variables or a secure credential store")
            
        # Validate credentials format (basic check)
        if not self.msfrpc_username or not self.msfrpc_password:
            logger.warning("MSFRPC credentials are empty or invalid")
    
    def load_exploits(self, exploit_type: Optional[ExploitType] = None) -> Dict[str, Exploit]:
        """
        Load exploits from the exploits directory.
        
        Args:
            exploit_type: Filter by exploit type
            
        Returns:
            Dictionary of loaded exploits
        """
        logger.info(f"Loading exploits from {self.exploits_directory}")
        
        if not self.exploits_directory.exists():
            logger.warning(f"Exploits directory {self.exploits_directory} does not exist")
            return self.exploits
            
        # Find all JSON files in the directory
        for exploit_file in self.exploits_directory.glob("**/*.json"):
            try:
                self._load_exploit_file(exploit_file, exploit_type)
            except Exception as e:
                logger.error(f"Error loading exploit {exploit_file}: {str(e)}")
                
        logger.info(f"Loaded {len(self.exploits)} exploits")
        return self.exploits
        
    def _load_exploit_file(self, exploit_file: Path, exploit_type: Optional[ExploitType] = None) -> Optional[Exploit]:
        """
        Load an exploit from a file.
        
        Args:
            exploit_file: Path to the exploit file
            exploit_type: Filter by exploit type
            
        Returns:
            Loaded exploit or None
        """
        try:
            with open(exploit_file, 'r') as f:
                exploit_data = json.load(f)
                
            # Extract exploit type
            type_str = exploit_data.get("type", "metasploit").lower()
            try:
                parsed_type = ExploitType[type_str.upper()]
            except KeyError:
                parsed_type = ExploitType.METASPLOIT
                
            # Skip if not matching requested type
            if exploit_type and parsed_type != exploit_type:
                return None
                
            # Create exploit object
            exploit = Exploit(
                id=exploit_data.get("id", str(uuid.uuid4())),
                name=exploit_data.get("name", exploit_file.stem),
                description=exploit_data.get("description", ""),
                type=parsed_type,
                module_path=exploit_data.get("module_path"),
                options=exploit_data.get("options", {}),
                references=exploit_data.get("references", []),
                author=exploit_data.get("author"),
                code=exploit_data.get("code"),
                target_requirements=exploit_data.get("target_requirements", {})
            )
            
            # Store the exploit
            self.exploits[exploit.id] = exploit
            return exploit
            
        except Exception as e:
            logger.error(f"Failed to load exploit {exploit_file}: {str(e)}")
            return None
            
    def save_exploit(self, exploit: Exploit) -> bool:
        """
        Save an exploit to the exploits directory.
        
        Args:
            exploit: Exploit to save
            
        Returns:
            True if successful, False otherwise
        """
        if not self.exploits_directory.exists():
            self.exploits_directory.mkdir(parents=True, exist_ok=True)
            
        try:
            # Create file path
            file_name = f"{exploit.id}.json"
            file_path = self.exploits_directory / file_name
            
            # Create exploit data
            exploit_data = exploit.to_dict()
            if exploit.code:
                exploit_data["code"] = exploit.code
                
            # Write to file
            with open(file_path, 'w') as f:
                json.dump(exploit_data, f, indent=2)
                
            # Update cache
            self.exploits[exploit.id] = exploit
            
            logger.info(f"Saved exploit {exploit.id} to {file_path}")
            return True
            
        except Exception as e:
            logger.error(f"Error saving exploit {exploit.id}: {str(e)}")
            return False
            
    def get_exploit(self, exploit_id: str) -> Optional[Exploit]:
        """
        Get an exploit by ID.
        
        Args:
            exploit_id: Exploit ID
            
        Returns:
            Exploit or None if not found
        """
        if not self.exploits:
            self.load_exploits()
            
        return self.exploits.get(exploit_id)
            
    def test_exploit(self, exploit_id: str, target: str, 
                   options: Optional[Dict[str, Any]] = None,
                   use_container: Optional[bool] = None) -> ExploitResult:
        """
        Test an exploit against a target.
        
        Args:
            exploit_id: Exploit ID
            target: Target to test
            options: Exploit options (overrides those in exploit definition)
            use_container: Whether to use a container for isolation
            
        Returns:
            Exploit test result
        """
        # Get the exploit
        exploit = self.get_exploit(exploit_id)
        if not exploit:
            logger.error(f"Exploit {exploit_id} not found")
            return ExploitResult(
                id=str(uuid.uuid4()),
                exploit_id=exploit_id,
                target=target,
                status=ExploitStatus.ERROR,
                start_time=datetime.datetime.now(),
                end_time=datetime.datetime.now(),
                output="Exploit not found",
                details={"error": "Exploit not found"}
            )
            
        # Create result object
        result_id = str(uuid.uuid4())
        result = ExploitResult(
            id=result_id,
            exploit_id=exploit_id,
            target=target,
            status=ExploitStatus.PENDING,
            start_time=datetime.datetime.now()
        )
        
        logger.info(f"Testing exploit {exploit.name} against {target}")
        
        try:
            # Update status
            result.status = ExploitStatus.RUNNING
            
            # Merge options
            merged_options = exploit.options.copy()
            if options:
                merged_options.update(options)
                
            # Set target in options if needed
            if "RHOSTS" in merged_options and not merged_options["RHOSTS"]:
                merged_options["RHOSTS"] = target
            elif "RHOST" in merged_options and not merged_options["RHOST"]:
                merged_options["RHOST"] = target
                
            # Determine whether to use a container
            should_use_container = use_container if use_container is not None else self.use_containers
            
            # Run the appropriate exploit test method
            if exploit.type == ExploitType.METASPLOIT:
                if should_use_container:
                    test_result = self._test_msf_exploit_containerized(exploit, merged_options, result_id)
                else:
                    test_result = self._test_msf_exploit_rpc(exploit, merged_options, result_id)
            elif exploit.type == ExploitType.CUSTOM:
                test_result = self._test_custom_exploit(exploit, target, merged_options, should_use_container)
            elif exploit.type == ExploitType.POC:
                test_result = self._test_poc_exploit(exploit, target, merged_options, should_use_container)
            else:
                raise ValueError(f"Unsupported exploit type: {exploit.type}")
                
            # Update result with test results
            result.status = test_result["status"]
            result.output = test_result["output"]
            result.session_id = test_result.get("session_id")
            result.details = test_result.get("details", {})
            
        except Exception as e:
            logger.error(f"Error testing exploit: {str(e)}")
            result.status = ExploitStatus.ERROR
            result.output = f"Error: {str(e)}"
            result.details = {"error": str(e)}
            
        finally:
            # Set end time
            result.end_time = datetime.datetime.now()
            
            # Store result in database
            self._store_exploit_result(result)
            
        return result
        
    def _test_msf_exploit_rpc(self, exploit: Exploit, options: Dict[str, Any], 
                            result_id: str) -> Dict[str, Any]:
        """
        Test a Metasploit exploit using the MSFRPC API.
        
        Args:
            exploit: Exploit to test
            options: Exploit options
            result_id: Result ID
            
        Returns:
            Dict containing test results
        """
        logger.info(f"Testing MSF exploit via RPC: {exploit.module_path}")
        
        try:
            # Ensure connected to MSFRPC
            if not self._connect_to_msfrpc():
                return {
                    "status": ExploitStatus.ERROR,
                    "output": "Failed to connect to Metasploit RPC",
                    "details": {"error": "MSFRPC connection failed"}
                }
                
            # Create a console to work with
            console_id = self._msfrpc_call("console.create")["id"]
            
            # Set up the exploit
            setup_commands = [
                f"use {exploit.module_path}",
            ]
            
            # Add options
            for option, value in options.items():
                setup_commands.append(f"set {option} {value}")
                
            # Run the setup commands
            for cmd in setup_commands:
                self._msfrpc_console_execute(console_id, cmd)
                
            # Run the exploit
            logger.info(f"Running exploit {exploit.module_path}")
            output = self._msfrpc_console_execute(console_id, "exploit -j")
            
            # Wait a bit and check for sessions
            time.sleep(5)
            sessions = self._msfrpc_call("session.list")
            
            # Check result
            if sessions and len(sessions) > 0:
                # We have a session, the exploit was successful
                session_id = list(sessions.keys())[0]
                session_info = sessions[session_id]
                
                # Get some output from the session if it's a shell or meterpreter
                session_output = ""
                if session_info.get("type") in ("shell", "meterpreter"):
                    try:
                        # Try to get some basic info
                        if session_info.get("type") == "meterpreter":
                            session_output = self._msfrpc_call("session.meterpreter_read", [session_id])
                            self._msfrpc_call("session.meterpreter_write", [session_id, "sysinfo\n"])
                            time.sleep(1)
                            session_output += self._msfrpc_call("session.meterpreter_read", [session_id])
                        else:
                            session_output = self._msfrpc_call("session.shell_read", [session_id])
                            self._msfrpc_call("session.shell_write", [session_id, "id\n"])
                            time.sleep(1)
                            session_output += self._msfrpc_call("session.shell_read", [session_id])
                    except Exception as e:
                        logger.error(f"Error reading from session: {str(e)}")
                        
                # Clean up the session
                try:
                    self._msfrpc_call("session.stop", [session_id])
                except Exception as e:
                    logger.error(f"Error stopping session: {str(e)}")
                    
                return {
                    "status": ExploitStatus.SUCCESS,
                    "output": output + "\n\n" + session_output,
                    "session_id": session_id,
                    "details": {"session_info": session_info}
                }
            else:
                # No session, the exploit likely failed
                return {
                    "status": ExploitStatus.FAILED,
                    "output": output,
                    "details": {"console_output": output}
                }
                
        except Exception as e:
            logger.error(f"Error during MSF RPC exploit test: {str(e)}")
            return {
                "status": ExploitStatus.ERROR,
                "output": f"Error: {str(e)}",
                "details": {"error": str(e)}
            }
        finally:
            # Clean up console
            try:
                if console_id:
                    self._msfrpc_call("console.destroy", [console_id])
            except Exception as e:
                logger.error(f"Error destroying console: {str(e)}")
                
    def _test_msf_exploit_containerized(self, exploit: Exploit, options: Dict[str, Any], 
                                      result_id: str) -> Dict[str, Any]:
        """
        Test a Metasploit exploit in a container for isolation.
        
        Args:
            exploit: Exploit to test
            options: Exploit options
            result_id: Result ID
            
        Returns:
            Dict containing test results
        """
        logger.info(f"Testing MSF exploit in container: {exploit.module_path}")
        
        # Create temporary files for resource script and output
        with tempfile.NamedTemporaryFile(mode='w', suffix='.rc', delete=False) as rc_file, \
             tempfile.NamedTemporaryFile(mode='w+', suffix='.txt', delete=False) as output_file:
            
            rc_path = rc_file.name
            output_path = output_file.name
            
            try:
                # Write the Metasploit resource script
                rc_file.write(f"use {exploit.module_path}\n")
                
                # Set options
                for option, value in options.items():
                    rc_file.write(f"set {option} {value}\n")
                    
                # Set up logging and run the exploit
                rc_file.write("set ConsoleLogging true\n")
                rc_file.write("set LogLevel 5\n")
                rc_file.write("exploit\n")
                rc_file.write("sleep 10\n")  # Wait for exploit to complete
                
                # Check for sessions
                rc_file.write("sessions -l\n")
                
                # Exit
                rc_file.write("exit\n")
                
                rc_file.flush()
                
                # Run Metasploit in a container
                cmd = [
                    "docker", "run", "--rm", "--network=host",
                    "-v", f"{rc_path}:/tmp/exploit.rc:ro",
                    "-v", f"{output_path}:/tmp/output.txt",
                    self.container_image,
                    "/bin/sh", "-c", "msfconsole -r /tmp/exploit.rc | tee /tmp/output.txt"
                ]
                
                # Run the container
                logger.info(f"Running container for exploit {exploit.module_path}")
                process = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
                
                # Read the output
                with open(output_path, 'r') as f:
                    output = f.read()
                    
                # Check if the exploit was successful by looking for session info
                if "Session" in output and "opened" in output:
                    # Extract session ID
                    session_match = re.search(r"Session (\d+) created in the background", output)
                    session_id = session_match.group(1) if session_match else "unknown"
                    
                    return {
                        "status": ExploitStatus.SUCCESS,
                        "output": output,
                        "session_id": session_id,
                        "details": {"container_stdout": process.stdout, "container_stderr": process.stderr}
                    }
                else:
                    return {
                        "status": ExploitStatus.FAILED,
                        "output": output,
                        "details": {"container_stdout": process.stdout, "container_stderr": process.stderr}
                    }
                    
            except subprocess.TimeoutExpired:
                logger.error(f"Container execution timed out for exploit {exploit.module_path}")
                return {
                    "status": ExploitStatus.ERROR,
                    "output": "Container execution timed out",
                    "details": {"error": "Timeout"}
                }
            except Exception as e:
                logger.error(f"Error running containerized exploit: {str(e)}")
                return {
                    "status": ExploitStatus.ERROR,
                    "output": f"Error: {str(e)}",
                    "details": {"error": str(e)}
                }
            finally:
                # Clean up temporary files
                try:
                    os.unlink(rc_path)
                    os.unlink(output_path)
                except:
                    pass
                    
    def _test_custom_exploit(self, exploit: Exploit, target: str, options: Dict[str, Any], 
                          use_container: bool) -> Dict[str, Any]:
        """
        Test a custom exploit against a target.
        
        Args:
            exploit: Exploit to test
            target: Target to test
            options: Exploit options
            use_container: Whether to use a container for isolation
            
        Returns:
            Dict containing test results
        """
        logger.info(f"Testing custom exploit: {exploit.name} against {target}")
        
        if not exploit.code:
            return {
                "status": ExploitStatus.ERROR,
                "output": "No exploit code found",
                "details": {"error": "Missing exploit code"}
            }
            
        # Determine the language from the code
        language = self._detect_exploit_language(exploit.code)
        
        # Create temporary files for exploit code and output
        with tempfile.NamedTemporaryFile(mode='w', suffix=self._get_file_extension(language), delete=False) as code_file, \
             tempfile.NamedTemporaryFile(mode='w+', suffix='.txt', delete=False) as output_file:
            
            code_path = code_file.name
            output_path = output_file.name
            
            try:
                # Replace placeholders in the code
                code = exploit.code
                code = code.replace("{{TARGET}}", target)
                
                for option, value in options.items():
                    code = code.replace(f"{{{{{option}}}}}", str(value))
                    
                # Write the code
                code_file.write(code)
                code_file.flush()
                
                if use_container:
                    # Run in a container
                    result = self._run_exploit_in_container(code_path, language, output_path)
                else:
                    # Run locally
                    result = self._run_exploit_locally(code_path, language, output_path)
                    
                # Read output file
                with open(output_path, 'r') as f:
                    output = f.read()
                    
                # Check for success markers in output
                if "SUCCESS" in output or "Exploit successful" in output:
                    status = ExploitStatus.SUCCESS
                elif "FAILED" in output or "Exploit failed" in output:
                    status = ExploitStatus.FAILED
                else:
                    # Check for common success indicators
                    success_indicators = [
                        "shell", "root@", "administrator", "meterpreter",
                        "command execution", "code execution"
                    ]
                    
                    if any(indicator in output.lower() for indicator in success_indicators):
                        status = ExploitStatus.SUCCESS
                    else:
                        status = ExploitStatus.FAILED
                        
                return {
                    "status": status,
                    "output": output,
                    "details": result
                }
                
            except Exception as e:
                logger.error(f"Error testing custom exploit: {str(e)}")
                return {
                    "status": ExploitStatus.ERROR,
                    "output": f"Error: {str(e)}",
                    "details": {"error": str(e)}
                }
            finally:
                # Clean up temporary files
                try:
                    os.unlink(code_path)
                    os.unlink(output_path)
                except:
                    pass
                    
    def _test_poc_exploit(self, exploit: Exploit, target: str, options: Dict[str, Any], 
                       use_container: bool) -> Dict[str, Any]:
        """
        Test a proof-of-concept exploit against a target.
        
        Args:
            exploit: Exploit to test
            target: Target to test
            options: Exploit options
            use_container: Whether to use a container for isolation
            
        Returns:
            Dict containing test results
        """
        logger.info(f"Testing PoC exploit: {exploit.name} against {target}")
        
        # PoC exploits are simpler versions of custom exploits
        return self._test_custom_exploit(exploit, target, options, use_container)
        
    def _detect_exploit_language(self, code: str) -> str:
        """
        Detect the programming language of an exploit.
        
        Args:
            code: Exploit code
            
        Returns:
            Language identifier
        """
        # Check for common language identifiers
        if code.startswith("#!/usr/bin/env python") or "import " in code or "from " in code and " import " in code:
            return "python"
        elif code.startswith("#!/usr/bin/env ruby") or "require '" in code or "require_relative " in code:
            return "ruby"
        elif code.startswith("#!/bin/bash") or code.startswith("#!/bin/sh"):
            return "bash"
        elif "<?php" in code:
            return "php"
        elif "public static void main" in code or "public class " in code:
            return "java"
        elif "#include <" in code and (code.endswith(".c") or ".h>" in code):
            return "c"
        elif "#include <" in code and (code.endswith(".cpp") or ".hpp>" in code):
            return "cpp"
        elif "function " in code and ("() {" in code or "(){" in code):
            return "javascript"
        else:
            return "unknown"
            
    def _get_file_extension(self, language: str) -> str:
        """
        Get the file extension for a language.
        
        Args:
            language: Language identifier
            
        Returns:
            File extension
        """
        extensions = {
            "python": ".py",
            "ruby": ".rb",
            "bash": ".sh",
            "php": ".php",
            "java": ".java",
            "c": ".c",
            "cpp": ".cpp",
            "javascript": ".js",
            "unknown": ".txt",
        }
        
        return extensions.get(language, ".txt")
        
    def _run_exploit_in_container(self, code_path: str, language: str, output_path: str) -> Dict[str, Any]:
        """
        Run an exploit in a container for isolation.
        
        Args:
            code_path: Path to the exploit code
            language: Language of the exploit
            output_path: Path to write output
            
        Returns:
            Dict containing execution details
        """
        # Determine the container image based on language
        container_image = self._get_container_image(language)
        
        # Determine how to run the code in the container
        run_command = self._get_run_command(language, "/tmp/exploit")
        
        # Run in container
        cmd = [
            "docker", "run", "--rm", "--network=host",
            "-v", f"{code_path}:/tmp/exploit:ro",
            "-v", f"{output_path}:/tmp/output.txt",
            container_image,
            "/bin/sh", "-c", f"{run_command} | tee /tmp/output.txt"
        ]
        
        # Run the container
        process = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
        
        return {
            "container_stdout": process.stdout,
            "container_stderr": process.stderr,
            "container_exit_code": process.returncode
        }
        
    def _run_exploit_locally(self, code_path: str, language: str, output_path: str) -> Dict[str, Any]:
        """
        Run an exploit locally with security precautions.
        
        Args:
            code_path: Path to the exploit code
            language: Language of the exploit
            output_path: Path to write output
            
        Returns:
            Dict containing execution details
        """
        # Security check: Verify if local execution is allowed
        if not self.config.get("allow_local_execution", False):
            logger.warning("Local exploit execution is disabled by configuration")
            return {
                "stdout": "",
                "stderr": "Local exploit execution is disabled for security reasons. Use containers instead.",
                "exit_code": 1,
                "security_blocked": True
            }
            
        # Security check: Scan code for potentially dangerous operations
        dangerous_patterns = self._check_code_for_dangerous_patterns(code_path)
        if dangerous_patterns and not self.config.get("bypass_security_checks", False):
            logger.warning(f"Potentially dangerous code detected in exploit: {dangerous_patterns}")
            return {
                "stdout": "",
                "stderr": f"Security check failed: Potentially dangerous code patterns detected: {', '.join(dangerous_patterns)}",
                "exit_code": 1,
                "security_blocked": True,
                "dangerous_patterns": dangerous_patterns
            }
            
        # Determine how to run the code locally
        run_command = self._get_run_command(language, code_path)
        
        # Make the code executable if it's a script
        if language in ["python", "ruby", "bash"]:
            os.chmod(code_path, 0o755)
            
        # Set resource limits and security context if possible
        env = os.environ.copy()
        
        # Set timeout for execution
        timeout = self.config.get("local_execution_timeout", 300)
        
        # Run locally with security precautions
        try:
            with open(output_path, 'w') as f:
                # Use shell=False when possible for better security
                if language in ["python", "ruby", "bash", "php"]:
                    cmd_parts = run_command.split()
                    process = subprocess.run(
                        cmd_parts, 
                        shell=False, 
                        capture_output=True, 
                        text=True, 
                        timeout=timeout,
                        env=env
                    )
                else:
                    # Fall back to shell=True for complex commands
                    process = subprocess.run(
                        run_command, 
                        shell=True, 
                        capture_output=True, 
                        text=True, 
                        timeout=timeout,
                        env=env
                    )
                    
                f.write(process.stdout)
                if process.stderr:
                    f.write("\n--- STDERR ---\n")
                    f.write(process.stderr)
                    
            return {
                "stdout": process.stdout,
                "stderr": process.stderr,
                "exit_code": process.returncode
            }
            
        except subprocess.TimeoutExpired:
            logger.error(f"Exploit execution timed out after {timeout} seconds")
            return {
                "stdout": "",
                "stderr": f"Execution timed out after {timeout} seconds",
                "exit_code": 124,  # Standard timeout exit code
                "timeout": True
            }
        except Exception as e:
            logger.error(f"Error executing exploit locally: {str(e)}")
            return {
                "stdout": "",
                "stderr": f"Execution error: {str(e)}",
                "exit_code": 1,
                "error": str(e)
            }
            
    def _check_code_for_dangerous_patterns(self, code_path: str) -> List[str]:
        """
        Check exploit code for potentially dangerous patterns.
        
        Args:
            code_path: Path to the exploit code
            
        Returns:
            List of detected dangerous patterns
        """
        dangerous_patterns = []
        
        try:
            with open(code_path, 'r') as f:
                code = f.read()
                
            # Define patterns to check for different languages
            patterns = {
                # System command execution
                r'(?:os\.system|subprocess\.(?:call|run|Popen)|exec\s*\(|eval\s*\(|execfile\s*\()': "System command execution",
                # File operations outside of working directory
                r'(?:open|file)\s*\([^)]*(?:\/etc\/|\/var\/|\/root\/|\/home\/)': "File access outside working directory",
                # Network operations to internal networks
                r'(?:connect|socket)[^)]*(?:127\.0\.0|192\.168|10\.|172\.)': "Internal network access",
                # Dangerous imports
                r'import\s+(?:os|subprocess|sys|shutil|pty)': "Potentially dangerous module import",
                # Shell commands
                r'(?:rm\s+-rf|chmod\s+777|mkfs)': "Destructive shell commands",
                # Persistence mechanisms
                r'(?:crontab|systemctl|service\s+[a-z]+\s+start)': "System service manipulation"
            }
            
            # Check for each pattern
            for pattern, description in patterns.items():
                if re.search(pattern, code, re.IGNORECASE):
                    dangerous_patterns.append(description)
                    
            return dangerous_patterns
            
        except Exception as e:
            logger.error(f"Error checking code for dangerous patterns: {str(e)}")
            return ["Error analyzing code safety"]
        
    def _get_container_image(self, language: str) -> str:
        """
        Get the container image for a language.
        
        Args:
            language: Language identifier
            
        Returns:
            Container image name
        """
        images = {
            "python": "python:3.9-slim",
            "ruby": "ruby:latest",
            "bash": "bash:latest",
            "php": "php:latest",
            "java": "openjdk:latest",
            "c": "gcc:latest",
            "cpp": "gcc:latest",
            "javascript": "node:latest",
            "unknown": "ubuntu:latest",
        }
        
        return images.get(language, "ubuntu:latest")
        
    def _get_run_command(self, language: str, code_path: str) -> str:
        """
        Get the command to run an exploit.
        
        Args:
            language: Language identifier
            code_path: Path to the exploit code
            
        Returns:
            Command to run the exploit
        """
        commands = {
            "python": f"python {code_path}",
            "ruby": f"ruby {code_path}",
            "bash": f"bash {code_path}",
            "php": f"php {code_path}",
            "java": f"javac {code_path} && java {os.path.splitext(os.path.basename(code_path))[0]}",
            "c": f"gcc {code_path} -o {code_path}.bin && {code_path}.bin",
            "cpp": f"g++ {code_path} -o {code_path}.bin && {code_path}.bin",
            "javascript": f"node {code_path}",
            "unknown": f"cat {code_path}",
        }
        
        return commands.get(language, f"cat {code_path}")
        
    def generate_report(self, result: ExploitResult, format: str = "html") -> str:
        """
        Generate a report for an exploit test result.
        
        Args:
            result: Exploit test result
            format: Report format (html, json, text)
            
        Returns:
            Generated report
        """
        # Get the exploit
        exploit = self.get_exploit(result.exploit_id)
        if not exploit:
            logger.error(f"Exploit {result.exploit_id} not found")
            return f"Error: Exploit {result.exploit_id} not found"
            
        if format == "json":
            # Generate JSON report
            report_data = {
                "result": result.to_dict(),
                "exploit": exploit.to_dict()
            }
            return json.dumps(report_data, indent=2)
        elif format == "text":
            # Generate text report
            report = [
                f"Exploit Test Report",
                f"===================",
                f"",
                f"Exploit: {exploit.name} ({exploit.id})",
                f"Target: {result.target}",
                f"Status: {result.status.value}",
                f"Start Time: {result.start_time.isoformat()}",
                f"End Time: {result.end_time.isoformat() if result.end_time else 'N/A'}",
                f"Duration: {(result.end_time - result.start_time).total_seconds() if result.end_time else 'N/A'} seconds",
                f"",
                f"Description:",
                f"{exploit.description}",
                f"",
                f"Output:",
                f"{result.output}"
            ]
            return "\n".join(report)
        else:  # HTML
            # Generate HTML report
            template_path = self.report_template_directory / "exploit_report.html"
            if not template_path.exists():
                # Create a basic template if it doesn't exist
                self._create_default_report_template()
                
            # Load the template
            env = jinja2.Environment(
                loader=jinja2.FileSystemLoader(str(self.report_template_directory)),
                autoescape=jinja2.select_autoescape(['html', 'xml'])
            )
            template = env.get_template("exploit_report.html")
            
            # Render the template
            return template.render(
                result=result,
                exploit=exploit,
                now=datetime.datetime.now()
            )
            
    def _create_default_report_template(self) -> None:
        """Create a default HTML report template."""
        if not self.report_template_directory.exists():
            self.report_template_directory.mkdir(parents=True, exist_ok=True)
            
        template_path = self.report_template_directory / "exploit_report.html"
        
        template = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exploit Test Report</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            border-bottom: 2px solid #ddd;
            padding-bottom: 20px;
            margin-bottom: 20px;
        }
        .header h1 {
            margin-bottom: 5px;
            color: #2c3e50;
        }
        .section {
            margin-bottom: 30px;
        }
        .section h2 {
            color: #3498db;
            margin-bottom: 10px;
        }
        .info-box {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .info-item {
            margin-bottom: 10px;
        }
        .info-item strong {
            width: 150px;
            display: inline-block;
        }
        .success {
            color: green;
            font-weight: bold;
        }
        .failure {
            color: red;
            font-weight: bold;
        }
        .error {
            color: orangered;
            font-weight: bold;
        }
        .output-box {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            white-space: pre-wrap;
            font-family: monospace;
        }
        .footer {
            border-top: 1px solid #ddd;
            padding-top: 20px;
            margin-top: 40px;
            text-align: center;
            font-size: 0.8em;
            color: #7f8c8d;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Exploit Test Report</h1>
            <p>Generated on {{ now.strftime('%Y-%m-%d %H:%M:%S') }}</p>
        </div>
        
        <div class="section">
            <h2>Test Information</h2>
            <div class="info-box">
                <div class="info-item">
                    <strong>Status:</strong> 
                    <span class="{{ result.status.value }}">{{ result.status.value.upper() }}</span>
                </div>
                <div class="info-item">
                    <strong>Target:</strong> {{ result.target }}
                </div>
                <div class="info-item">
                    <strong>Start Time:</strong> {{ result.start_time.strftime('%Y-%m-%d %H:%M:%S') }}
                </div>
                <div class="info-item">
                    <strong>End Time:</strong> {{ result.end_time.strftime('%Y-%m-%d %H:%M:%S') if result.end_time else 'N/A' }}
                </div>
                <div class="info-item">
                    <strong>Duration:</strong> 
                    {{ (result.end_time - result.start_time).total_seconds() if result.end_time else 'N/A' }} seconds
                </div>
                {% if result.session_id %}
                <div class="info-item">
                    <strong>Session ID:</strong> {{ result.session_id }}
                </div>
                {% endif %}
            </div>
        </div>
        
        <div class="section">
            <h2>Exploit Information</h2>
            <div class="info-box">
                <div class="info-item">
                    <strong>Name:</strong> {{ exploit.name }}
                </div>
                <div class="info-item">
                    <strong>ID:</strong> {{ exploit.id }}
                </div>
                <div class="info-item">
                    <strong>Type:</strong> {{ exploit.type.value }}
                </div>
                {% if exploit.module_path %}
                <div class="info-item">
                    <strong>Module Path:</strong> {{ exploit.module_path }}
                </div>
                {% endif %}
                <div class="info-item">
                    <strong>Author:</strong> {{ exploit.author or 'Unknown' }}
                </div>
                <div class="info-item">
                    <strong>Description:</strong> {{ exploit.description }}
                </div>
                {% if exploit.references %}
                <div class="info-item">
                    <strong>References:</strong>
                    <ul>
                        {% for ref in exploit.references %}
                        <li><a href="{{ ref }}">{{ ref }}</a></li>
                        {% endfor %}
                    </ul>
                </div>
                {% endif %}
            </div>
        </div>
        
        <div class="section">
            <h2>Test Output</h2>
            <div class="output-box">{{ result.output or 'No output available' }}</div>
        </div>
        
        <div class="footer">
            <p>Generated by SKrulll Exploit Tester</p>
        </div>
    </div>
</body>
</html>"""
        
        with open(template_path, 'w') as f:
            f.write(template)
        
    def _connect_to_msfrpc(self) -> bool:
        """
        Connect to the Metasploit RPC server.
        
        Returns:
            True if successful, False otherwise
        """
        if self.msf_api_token:
            # Already connected
            return True
            
        try:
            # Connect to MSFRPC
            auth_url = f"http://{self.msfrpc_host}:{self.msfrpc_port}/api/1.0/auth/login"
            headers = {"Content-Type": "binary/message-pack"}
            
            # Prepare login data
            auth_data = msgpack.packb({
                "method": "auth.login",
                "params": [self.msfrpc_username, self.msfrpc_password]
            })
            
            # Send request
            response = requests.post(auth_url, headers=headers, data=auth_data)
            
            # Parse response
            if response.status_code == 200:
                result = msgpack.unpackb(response.content)
                if "error" in result and result["error"]:
                    logger.error(f"MSFRPC authentication error: {result['error_message']}")
                    return False
                    
                # Extract token
                self.msf_api_token = result["result"]["token"]
                logger.info("Successfully connected to MSFRPC")
                return True
            else:
                logger.error(f"MSFRPC connection failed: {response.status_code} {response.reason}")
                return False
                
        except Exception as e:
            logger.error(f"Error connecting to MSFRPC: {str(e)}")
            return False
            
    def _msfrpc_call(self, method: str, params: List[Any] = None) -> Any:
        """
        Make a call to the Metasploit RPC API.
        
        Args:
            method: Method to call
            params: Parameters for the method
            
        Returns:
            Result of the RPC call
        """
        if not self.msf_api_token and not self._connect_to_msfrpc():
            raise Exception("Not connected to MSFRPC")
            
        # Prepare RPC data
        rpc_data = {
            "method": method,
            "params": [self.msf_api_token]
        }
        
        if params:
            rpc_data["params"].extend(params)
            
        # Pack the data
        packed_data = msgpack.packb(rpc_data)
        
        # Send request
        headers = {"Content-Type": "binary/message-pack"}
        url = f"http://{self.msfrpc_host}:{self.msfrpc_port}/api/1.0/auth/token"
        
        response = requests.post(url, headers=headers, data=packed_data)
        
        if response.status_code != 200:
            raise Exception(f"MSFRPC request failed: {response.status_code} {response.reason}")
            
        # Parse response
        result = msgpack.unpackb(response.content)
        
        if "error" in result and result["error"]:
            # Check if token expired
            if "Invalid Authentication Token" in result.get("error_message", ""):
                # Try to reconnect
                self.msf_api_token = None
                if self._connect_to_msfrpc():
                    # Retry the call
                    return self._msfrpc_call(method, params)
                    
            raise Exception(f"MSFRPC error: {result['error_message']}")
            
        return result["result"]
        
    def _msfrpc_console_execute(self, console_id: str, command: str, timeout: int = 60) -> str:
        """
        Execute a command in a Metasploit console.
        
        Args:
            console_id: Console ID
            command: Command to execute
            timeout: Maximum time to wait for command completion (seconds)
            
        Returns:
            Command output
        """
        # Write command to console
        self._msfrpc_call("console.write", [console_id, command + "\n"])
        
        # Wait for command to complete with timeout
        busy = True
        output = ""
        start_time = time.time()
        
        # Use exponential backoff for polling
        wait_time = 0.1  # Start with 100ms
        max_wait = 2.0   # Cap at 2 seconds
        
        while busy:
            # Check for timeout
            if time.time() - start_time > timeout:
                logger.warning(f"Command execution timed out after {timeout} seconds: {command}")
                output += "\n[TIMEOUT] Command execution timed out"
                break
                
            # Sleep with exponential backoff
            time.sleep(wait_time)
            wait_time = min(wait_time * 1.5, max_wait)
            
            # Read console output
            try:
                result = self._msfrpc_call("console.read", [console_id])
                output += result["data"]
                busy = result["busy"]
                
                # If we got substantial output but command is still running,
                # we can reset the backoff to be more responsive
                if len(result["data"]) > 10:
                    wait_time = 0.1
            except Exception as e:
                logger.error(f"Error reading console output: {str(e)}")
                output += f"\n[ERROR] Console read error: {str(e)}"
                break
            
        return output
        
    def _store_exploit_result(self, result: ExploitResult) -> bool:
        """
        Store an exploit test result in the database.
        
        Args:
            result: Exploit test result
            
        Returns:
            True if successful, False otherwise
        """
        if not self.db_connection_string:
            logger.warning("Database connection string not provided, skipping result storage")
            return False
            
        try:
            # Connect to database
            conn = psycopg2.connect(self.db_connection_string)
            cursor = conn.cursor()
            
            # Create tables if they don't exist
            self._ensure_exploit_tables_exist(cursor)
            
            # Store result
            cursor.execute(
                """
                INSERT INTO exploit_results 
                (id, exploit_id, target, status, start_time, end_time, output, session_id, details)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
                """,
                (
                    result.id,
                    result.exploit_id,
                    result.target,
                    result.status.value,
                    result.start_time,
                    result.end_time,
                    result.output,
                    result.session_id,
                    Json(result.details)
                )
            )
            
            # Commit transaction
            conn.commit()
            cursor.close()
            conn.close()
            
            logger.info(f"Stored exploit result {result.id} in database")
            return True
            
        except Exception as e:
            logger.error(f"Error storing exploit result in database: {str(e)}")
            return False
            
    def _ensure_exploit_tables_exist(self, cursor) -> None:
        """
        Ensure that the necessary database tables for exploits exist.
        
        Args:
            cursor: Database cursor
        """
        # Create exploits table
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS exploits (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                description TEXT,
                type TEXT NOT NULL,
                module_path TEXT,
                options JSONB,
                references JSONB,
                author TEXT,
                target_requirements JSONB,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
            """
        )
        
        # Create exploit_results table
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS exploit_results (
                id TEXT PRIMARY KEY,
                exploit_id TEXT NOT NULL,
                target TEXT NOT NULL,
                status TEXT NOT NULL,
                start_time TIMESTAMP NOT NULL,
                end_time TIMESTAMP,
                output TEXT,
                session_id TEXT,
                details JSONB,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
            """
        )
        
        # Create indexes
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_exploit_results_exploit_id ON exploit_results(exploit_id)")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_exploit_results_status ON exploit_results(status)")


def test_exploit(exploit_id: str, target: str, options: Optional[Dict[str, Any]] = None,
               use_container: Optional[bool] = None, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Test an exploit against a target.
    
    Args:
        exploit_id: Exploit ID
        target: Target to test
        options: Exploit options
        use_container: Whether to use a container for isolation
        config: Tester configuration
        
    Returns:
        Dictionary containing test results
    """
    try:
        # Create tester
        tester = ExploitTester(config)
        
        # Run test
        result = tester.test_exploit(
            exploit_id=exploit_id,
            target=target,
            options=options,
            use_container=use_container
        )
        
        # Return results as dictionary
        return result.to_dict()
        
    except Exception as e:
        logger.error(f"Error testing exploit: {str(e)}")
        return {
            "status": "error",
            "error": str(e)
        }
